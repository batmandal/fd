"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@vis.gl";
exports.ids = ["vendor-chunks/@vis.gl"];
exports.modules = {

/***/ "(ssr)/../node_modules/@vis.gl/react-google-maps/dist/index.modern.mjs":
/*!***********************************************************************!*\
  !*** ../node_modules/@vis.gl/react-google-maps/dist/index.modern.mjs ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   APILoadingStatus: () => (/* binding */ APILoadingStatus),\n/* harmony export */   APIProvider: () => (/* binding */ APIProvider),\n/* harmony export */   APIProviderContext: () => (/* binding */ APIProviderContext),\n/* harmony export */   AdvancedMarker: () => (/* binding */ AdvancedMarker),\n/* harmony export */   AdvancedMarkerContext: () => (/* binding */ AdvancedMarkerContext),\n/* harmony export */   ControlPosition: () => (/* binding */ ControlPosition),\n/* harmony export */   GoogleMapsContext: () => (/* binding */ GoogleMapsContext),\n/* harmony export */   InfoWindow: () => (/* binding */ InfoWindow),\n/* harmony export */   Map: () => (/* binding */ Map),\n/* harmony export */   MapControl: () => (/* binding */ MapControl),\n/* harmony export */   Marker: () => (/* binding */ Marker),\n/* harmony export */   Pin: () => (/* binding */ Pin),\n/* harmony export */   isLatLngLiteral: () => (/* binding */ isLatLngLiteral),\n/* harmony export */   latLngEquals: () => (/* binding */ latLngEquals),\n/* harmony export */   limitTiltRange: () => (/* binding */ limitTiltRange),\n/* harmony export */   toLatLngLiteral: () => (/* binding */ toLatLngLiteral),\n/* harmony export */   useAdvancedMarkerRef: () => (/* binding */ useAdvancedMarkerRef),\n/* harmony export */   useApiIsLoaded: () => (/* binding */ useApiIsLoaded),\n/* harmony export */   useApiLoadingStatus: () => (/* binding */ useApiLoadingStatus),\n/* harmony export */   useMap: () => (/* binding */ useMap),\n/* harmony export */   useMapsLibrary: () => (/* binding */ useMapsLibrary),\n/* harmony export */   useMarkerRef: () => (/* binding */ useMarkerRef)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react-dom */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-dom.js\");\n/* harmony import */ var fast_deep_equal__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! fast-deep-equal */ \"(ssr)/../node_modules/fast-deep-equal/index.js\");\n\n\n\nfunction _toPrimitive(t, r) {\n    if (\"object\" != typeof t || !t) return t;\n    var e = t[Symbol.toPrimitive];\n    if (void 0 !== e) {\n        var i = e.call(t, r || \"default\");\n        if (\"object\" != typeof i) return i;\n        throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n    return (\"string\" === r ? String : Number)(t);\n}\nfunction _toPropertyKey(t) {\n    var i = _toPrimitive(t, \"string\");\n    return \"symbol\" == typeof i ? i : String(i);\n}\nfunction _extends() {\n    _extends = Object.assign ? Object.assign.bind() : function(target) {\n        for(var i = 1; i < arguments.length; i++){\n            var source = arguments[i];\n            for(var key in source){\n                if (Object.prototype.hasOwnProperty.call(source, key)) {\n                    target[key] = source[key];\n                }\n            }\n        }\n        return target;\n    };\n    return _extends.apply(this, arguments);\n}\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n    if (source == null) return {};\n    var target = {};\n    var sourceKeys = Object.keys(source);\n    var key, i;\n    for(i = 0; i < sourceKeys.length; i++){\n        key = sourceKeys[i];\n        if (excluded.indexOf(key) >= 0) continue;\n        target[key] = source[key];\n    }\n    return target;\n}\nconst APILoadingStatus = {\n    NOT_LOADED: \"NOT_LOADED\",\n    LOADING: \"LOADING\",\n    LOADED: \"LOADED\",\n    FAILED: \"FAILED\",\n    AUTH_FAILURE: \"AUTH_FAILURE\"\n};\nconst MAPS_API_BASE_URL = \"https://maps.googleapis.com/maps/api/js\";\n/**\n * A GoogleMapsApiLoader to reliably load and unload the Google Maps JavaScript API.\n *\n * The actual loading and unloading is delayed into the microtask queue, to\n * allow using the API in an useEffect hook, without worrying about multiple API loads.\n */ class GoogleMapsApiLoader {\n    /**\n   * Loads the Google Maps API with the specified parameters.\n   * Since the Maps library can only be loaded once per page, this will\n   * produce a warning when called multiple times with different\n   * parameters.\n   *\n   * The returned promise resolves when loading completes\n   * and rejects in case of an error or when the loading was aborted.\n   */ static async load(params, onLoadingStatusChange) {\n        var _window$google;\n        const libraries = params.libraries ? params.libraries.split(\",\") : [];\n        const serializedParams = this.serializeParams(params);\n        // note: if google.maps.importLibrary was defined externally, the params\n        //   will be ignored. If it was defined by a previous call to this\n        //   method, we will check that the key and other parameters have not been\n        //   changed in between calls.\n        if (!((_window$google = window.google) != null && (_window$google = _window$google.maps) != null && _window$google.importLibrary)) {\n            this.serializedApiParams = serializedParams;\n            this.initImportLibrary(params, onLoadingStatusChange);\n        } else {\n            // if serializedApiParams isn't defined the library was loaded externally\n            // and we can only assume that went alright.\n            if (!this.serializedApiParams) {\n                this.loadingStatus = APILoadingStatus.LOADED;\n            }\n            onLoadingStatusChange(this.loadingStatus);\n        }\n        if (this.serializedApiParams && this.serializedApiParams !== serializedParams) {\n            console.warn(`The maps API has already been loaded with different ` + `parameters and will not be loaded again. Refresh the page for ` + `new values to have effect.`);\n        }\n        for (const lib of [\n            \"maps\",\n            ...libraries\n        ]){\n            await google.maps.importLibrary(lib);\n        }\n    }\n    static serializeParams(params) {\n        return [\n            params.v,\n            params.key,\n            params.language,\n            params.region,\n            params.authReferrerPolicy,\n            params.solutionChannel\n        ].join(\"/\");\n    }\n    static initImportLibrary(params, onLoadingStatusChange) {\n        if (!window.google) window.google = {};\n        if (!window.google.maps) window.google.maps = {};\n        if (window.google.maps[\"importLibrary\"]) {\n            console.warn(\"initImportLibrary can only be called once.\", params);\n            return;\n        }\n        let apiPromise = null;\n        const loadApi = (library)=>{\n            if (apiPromise) return apiPromise;\n            apiPromise = new Promise((resolve, reject)=>{\n                var _document$querySelect;\n                const scriptElement = document.createElement(\"script\");\n                const urlParams = new URLSearchParams();\n                for (const [key, value] of Object.entries(params)){\n                    const urlParamName = key.replace(/[A-Z]/g, (t)=>\"_\" + t[0].toLowerCase());\n                    urlParams.set(urlParamName, value);\n                }\n                urlParams.set(\"libraries\", library);\n                urlParams.set(\"loading\", \"async\");\n                urlParams.set(\"callback\", \"__googleMapsCallback__\");\n                scriptElement.async = true;\n                scriptElement.src = MAPS_API_BASE_URL + `?` + urlParams.toString();\n                window.__googleMapsCallback__ = ()=>{\n                    this.loadingStatus = APILoadingStatus.LOADED;\n                    onLoadingStatusChange(this.loadingStatus);\n                    resolve();\n                };\n                window.gm_authFailure = ()=>{\n                    this.loadingStatus = APILoadingStatus.AUTH_FAILURE;\n                    onLoadingStatusChange(this.loadingStatus);\n                };\n                scriptElement.onerror = ()=>{\n                    this.loadingStatus = APILoadingStatus.FAILED;\n                    onLoadingStatusChange(this.loadingStatus);\n                    reject(new Error(\"The Google Maps JavaScript API could not load.\"));\n                };\n                scriptElement.nonce = ((_document$querySelect = document.querySelector(\"script[nonce]\")) == null ? void 0 : _document$querySelect.nonce) || \"\";\n                this.loadingStatus = APILoadingStatus.LOADING;\n                onLoadingStatusChange(this.loadingStatus);\n                document.head.append(scriptElement);\n            });\n            return apiPromise;\n        };\n        // for the first load, we declare an importLibrary function that will\n        // be overwritten once the api is loaded.\n        google.maps.importLibrary = (libraryName)=>loadApi(libraryName).then(()=>google.maps.importLibrary(libraryName));\n    }\n}\nGoogleMapsApiLoader.loadingStatus = APILoadingStatus.NOT_LOADED;\nGoogleMapsApiLoader.serializedApiParams = void 0;\nconst _excluded$3 = [\n    \"onLoad\",\n    \"apiKey\",\n    \"version\",\n    \"libraries\"\n], _excluded2 = [\n    \"children\"\n];\nconst APIProviderContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\n/**\n * local hook to set up the map-instance management context.\n */ function useMapInstances() {\n    const [mapInstances, setMapInstances] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({});\n    const addMapInstance = (mapInstance, id = \"default\")=>{\n        setMapInstances((instances)=>_extends({}, instances, {\n                [id]: mapInstance\n            }));\n    };\n    const removeMapInstance = (id = \"default\")=>{\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\n        setMapInstances((_ref)=>{\n            let remaining = _objectWithoutPropertiesLoose(_ref, [\n                id\n            ].map(_toPropertyKey));\n            return remaining;\n        });\n    };\n    const clearMapInstances = ()=>{\n        setMapInstances({});\n    };\n    return {\n        mapInstances,\n        addMapInstance,\n        removeMapInstance,\n        clearMapInstances\n    };\n}\n/**\n * local hook to handle the loading of the maps API, returns the current loading status\n * @param props\n */ function useGoogleMapsApiLoader(props) {\n    const { onLoad, apiKey, version, libraries = [] } = props, otherApiParams = _objectWithoutPropertiesLoose(props, _excluded$3);\n    const [status, setStatus] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(GoogleMapsApiLoader.loadingStatus);\n    const [loadedLibraries, addLoadedLibrary] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useReducer)((loadedLibraries, action)=>{\n        return _extends({}, loadedLibraries, {\n            [action.name]: action.value\n        });\n    }, {});\n    const librariesString = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>libraries == null ? void 0 : libraries.join(\",\"), [\n        libraries\n    ]);\n    const serializedParams = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>JSON.stringify(_extends({\n            apiKey,\n            version\n        }, otherApiParams)), [\n        apiKey,\n        version,\n        otherApiParams\n    ]);\n    const importLibrary = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async (name)=>{\n        var _google;\n        if (loadedLibraries[name]) {\n            return loadedLibraries[name];\n        }\n        if (!((_google = google) != null && (_google = _google.maps) != null && _google.importLibrary)) {\n            throw new Error(\"[api-provider-internal] importLibrary was called before \" + \"google.maps.importLibrary was defined.\");\n        }\n        const res = await window.google.maps.importLibrary(name);\n        addLoadedLibrary({\n            name,\n            value: res\n        });\n        return res;\n    }, [\n        loadedLibraries\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        (async ()=>{\n            try {\n                const params = _extends({\n                    key: apiKey\n                }, otherApiParams);\n                if (version) params.v = version;\n                if ((librariesString == null ? void 0 : librariesString.length) > 0) params.libraries = librariesString;\n                await GoogleMapsApiLoader.load(params, (status)=>setStatus(status));\n                for (const name of [\n                    \"core\",\n                    \"maps\",\n                    ...libraries\n                ]){\n                    await importLibrary(name);\n                }\n                if (onLoad) {\n                    onLoad();\n                }\n            } catch (error) {\n                console.error(\"<ApiProvider> failed to load Google Maps API\", error);\n            }\n        })();\n    }, // eslint-disable-next-line react-hooks/exhaustive-deps\n    [\n        apiKey,\n        librariesString,\n        serializedParams\n    ]);\n    return {\n        status,\n        loadedLibraries,\n        importLibrary\n    };\n}\n/**\n * Component to wrap the Google Maps React components and load the Google Maps JavaScript API\n */ const APIProvider = (props)=>{\n    const { children } = props, loaderProps = _objectWithoutPropertiesLoose(props, _excluded2);\n    const { mapInstances, addMapInstance, removeMapInstance, clearMapInstances } = useMapInstances();\n    const { status, loadedLibraries, importLibrary } = useGoogleMapsApiLoader(loaderProps);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(APIProviderContext.Provider, {\n        value: {\n            mapInstances,\n            addMapInstance,\n            removeMapInstance,\n            clearMapInstances,\n            status,\n            loadedLibraries,\n            importLibrary\n        }\n    }, children);\n};\n/**\n * Sets up effects to bind event-handlers for all event-props in MapEventProps.\n * @internal\n */ function useMapEvents(map, props) {\n    // note: calling a useEffect hook from within a loop is prohibited by the\n    // rules of hooks, but it's ok here since it's unconditional and the number\n    // and order of iterations is always strictly the same.\n    // (see https://legacy.reactjs.org/docs/hooks-rules.html)\n    for (const propName of eventPropNames){\n        // fixme: this cast is essentially a 'trust me, bro' for typescript, but\n        //   a proper solution seems way too complicated right now\n        const handler = props[propName];\n        const eventType = propNameToEventType[propName];\n        // eslint-disable-next-line react-hooks/rules-of-hooks\n        (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n            if (!map) return;\n            if (!handler) return;\n            const listener = google.maps.event.addListener(map, eventType, (ev)=>{\n                handler(createMapEvent(eventType, map, ev));\n            });\n            return ()=>listener.remove();\n        }, [\n            map,\n            eventType,\n            handler\n        ]);\n    }\n}\n/**\n * Create the wrapped map-events used for the event-props.\n * @param type the event type as it is specified to the maps api\n * @param map the map instance the event originates from\n * @param srcEvent the source-event if there is one.\n */ function createMapEvent(type, map, srcEvent) {\n    const ev = {\n        type,\n        map,\n        detail: {},\n        stoppable: false,\n        stop: ()=>{}\n    };\n    if (cameraEventTypes.includes(type)) {\n        const camEvent = ev;\n        const center = map.getCenter();\n        const zoom = map.getZoom();\n        const heading = map.getHeading() || 0;\n        const tilt = map.getTilt() || 0;\n        const bounds = map.getBounds();\n        if (!center || !bounds || !Number.isFinite(zoom)) {\n            console.warn(\"[createEvent] at least one of the values from the map \" + \"returned undefined. This is not expected to happen. Please \" + \"report an issue at https://github.com/visgl/react-google-maps/issues/new\");\n        }\n        camEvent.detail = {\n            center: (center == null ? void 0 : center.toJSON()) || {\n                lat: 0,\n                lng: 0\n            },\n            zoom: zoom || 0,\n            heading: heading,\n            tilt: tilt,\n            bounds: (bounds == null ? void 0 : bounds.toJSON()) || {\n                north: 90,\n                east: 180,\n                south: -90,\n                west: -180\n            }\n        };\n        return camEvent;\n    } else if (mouseEventTypes.includes(type)) {\n        var _srcEvent$latLng;\n        if (!srcEvent) throw new Error(\"[createEvent] mouse events must provide a srcEvent\");\n        const mouseEvent = ev;\n        mouseEvent.domEvent = srcEvent.domEvent;\n        mouseEvent.stoppable = true;\n        mouseEvent.stop = ()=>srcEvent.stop();\n        mouseEvent.detail = {\n            latLng: ((_srcEvent$latLng = srcEvent.latLng) == null ? void 0 : _srcEvent$latLng.toJSON()) || null,\n            placeId: srcEvent.placeId\n        };\n        return mouseEvent;\n    }\n    return ev;\n}\n/**\n * maps the camelCased names of event-props to the corresponding event-types\n * used in the maps API.\n */ const propNameToEventType = {\n    onBoundsChanged: \"bounds_changed\",\n    onCenterChanged: \"center_changed\",\n    onClick: \"click\",\n    onContextmenu: \"contextmenu\",\n    onDblclick: \"dblclick\",\n    onDrag: \"drag\",\n    onDragend: \"dragend\",\n    onDragstart: \"dragstart\",\n    onHeadingChanged: \"heading_changed\",\n    onIdle: \"idle\",\n    onIsFractionalZoomEnabledChanged: \"isfractionalzoomenabled_changed\",\n    onMapCapabilitiesChanged: \"mapcapabilities_changed\",\n    onMapTypeIdChanged: \"maptypeid_changed\",\n    onMousemove: \"mousemove\",\n    onMouseout: \"mouseout\",\n    onMouseover: \"mouseover\",\n    onProjectionChanged: \"projection_changed\",\n    onRenderingTypeChanged: \"renderingtype_changed\",\n    onTilesLoaded: \"tilesloaded\",\n    onTiltChanged: \"tilt_changed\",\n    onZoomChanged: \"zoom_changed\",\n    // note: onCameraChanged is an alias for the bounds_changed event,\n    // since that is going to be fired in every situation where the camera is\n    // updated.\n    onCameraChanged: \"bounds_changed\"\n};\nconst cameraEventTypes = [\n    \"bounds_changed\",\n    \"center_changed\",\n    \"heading_changed\",\n    \"projection_changed\",\n    \"tilt_changed\",\n    \"zoom_changed\"\n];\nconst mouseEventTypes = [\n    \"click\",\n    \"contextmenu\",\n    \"dblclick\",\n    \"mousemove\",\n    \"mouseout\",\n    \"mouseover\"\n];\nconst eventPropNames = Object.keys(propNameToEventType);\nfunction useDeepCompareEffect(effect, deps) {\n    const ref = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(undefined);\n    if (!ref.current || !fast_deep_equal__WEBPACK_IMPORTED_MODULE_2__(deps, ref.current)) {\n        ref.current = deps;\n    }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(effect, ref.current);\n}\nconst mapOptionKeys = new Set([\n    \"backgroundColor\",\n    \"clickableIcons\",\n    \"controlSize\",\n    \"disableDefaultUI\",\n    \"disableDoubleClickZoom\",\n    \"draggable\",\n    \"draggableCursor\",\n    \"draggingCursor\",\n    \"fullscreenControl\",\n    \"fullscreenControlOptions\",\n    \"gestureHandling\",\n    \"isFractionalZoomEnabled\",\n    \"keyboardShortcuts\",\n    \"mapTypeControl\",\n    \"mapTypeControlOptions\",\n    \"mapTypeId\",\n    \"maxZoom\",\n    \"minZoom\",\n    \"noClear\",\n    \"panControl\",\n    \"panControlOptions\",\n    \"restriction\",\n    \"rotateControl\",\n    \"rotateControlOptions\",\n    \"scaleControl\",\n    \"scaleControlOptions\",\n    \"scrollwheel\",\n    \"streetView\",\n    \"streetViewControl\",\n    \"streetViewControlOptions\",\n    \"styles\",\n    \"zoomControl\",\n    \"zoomControlOptions\"\n]);\n/**\n * Internal hook to update the map-options when props are changed.\n *\n * @param map the map instance\n * @param mapProps the props to update the map-instance with\n * @internal\n */ function useMapOptions(map, mapProps) {\n    /* eslint-disable react-hooks/exhaustive-deps --\n   *\n   * The following effects aren't triggered when the map is changed.\n   * In that case, the values will be or have been passed to the map\n   * constructor via mapOptions.\n   */ const mapOptions = {};\n    const keys = Object.keys(mapProps);\n    for (const key of keys){\n        if (!mapOptionKeys.has(key)) continue;\n        mapOptions[key] = mapProps[key];\n    }\n    // update the map options when mapOptions is changed\n    // Note: due to the destructuring above, mapOptions will be seen as changed\n    //   with every re-render, so we're assuming the maps-api will properly\n    //   deal with unchanged option-values passed into setOptions.\n    useDeepCompareEffect(()=>{\n        if (!map) return;\n        map.setOptions(mapOptions);\n    }, [\n        mapOptions\n    ]);\n/* eslint-enable react-hooks/exhaustive-deps */ }\nfunction useApiLoadingStatus() {\n    var _useContext;\n    return ((_useContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(APIProviderContext)) == null ? void 0 : _useContext.status) || APILoadingStatus.NOT_LOADED;\n}\n/**\n * Internal hook that updates the camera when deck.gl viewState changes.\n * @internal\n */ function useDeckGLCameraUpdate(map, props) {\n    const { viewport, viewState } = props;\n    const isDeckGlControlled = !!viewport;\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect)(()=>{\n        if (!map || !viewState) return;\n        const { latitude, longitude, bearing: heading, pitch: tilt, zoom } = viewState;\n        map.moveCamera({\n            center: {\n                lat: latitude,\n                lng: longitude\n            },\n            heading,\n            tilt,\n            zoom: zoom + 1\n        });\n    }, [\n        map,\n        viewState\n    ]);\n    return isDeckGlControlled;\n}\nfunction isLatLngLiteral(obj) {\n    if (!obj || typeof obj !== \"object\") return false;\n    if (!(\"lat\" in obj && \"lng\" in obj)) return false;\n    return Number.isFinite(obj.lat) && Number.isFinite(obj.lng);\n}\nfunction latLngEquals(a, b) {\n    if (!a || !b) return false;\n    const A = toLatLngLiteral(a);\n    const B = toLatLngLiteral(b);\n    if (A.lat !== B.lat || A.lng !== B.lng) return false;\n    return true;\n}\nfunction toLatLngLiteral(obj) {\n    if (isLatLngLiteral(obj)) return obj;\n    return obj.toJSON();\n}\nfunction useMapCameraParams(map, cameraStateRef, mapProps) {\n    const center = mapProps.center ? toLatLngLiteral(mapProps.center) : null;\n    let lat = null;\n    let lng = null;\n    if (center && Number.isFinite(center.lat) && Number.isFinite(center.lng)) {\n        lat = center.lat;\n        lng = center.lng;\n    }\n    const zoom = Number.isFinite(mapProps.zoom) ? mapProps.zoom : null;\n    const heading = Number.isFinite(mapProps.heading) ? mapProps.heading : null;\n    const tilt = Number.isFinite(mapProps.tilt) ? mapProps.tilt : null;\n    // the following effect runs for every render of the map component and checks\n    // if there are differences between the known state of the map instance\n    // (cameraStateRef, which is updated by all bounds_changed events) and the\n    // desired state in the props.\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect)(()=>{\n        if (!map) return;\n        const nextCamera = {};\n        let needsUpdate = false;\n        if (lat !== null && lng !== null && (cameraStateRef.current.center.lat !== lat || cameraStateRef.current.center.lng !== lng)) {\n            nextCamera.center = {\n                lat,\n                lng\n            };\n            needsUpdate = true;\n        }\n        if (zoom !== null && cameraStateRef.current.zoom !== zoom) {\n            nextCamera.zoom = zoom;\n            needsUpdate = true;\n        }\n        if (heading !== null && cameraStateRef.current.heading !== heading) {\n            nextCamera.heading = heading;\n            needsUpdate = true;\n        }\n        if (tilt !== null && cameraStateRef.current.tilt !== tilt) {\n            nextCamera.tilt = tilt;\n            needsUpdate = true;\n        }\n        if (needsUpdate) {\n            map.moveCamera(nextCamera);\n        }\n    });\n}\nconst AuthFailureMessage = ()=>{\n    const style = {\n        position: \"absolute\",\n        top: 0,\n        left: 0,\n        bottom: 0,\n        right: 0,\n        zIndex: 999,\n        display: \"flex\",\n        flexFlow: \"column nowrap\",\n        textAlign: \"center\",\n        justifyContent: \"center\",\n        fontSize: \".8rem\",\n        color: \"rgba(0,0,0,0.6)\",\n        background: \"#dddddd\",\n        padding: \"1rem 1.5rem\"\n    };\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n        style: style\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"h2\", null, \"Error: AuthFailure\"), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"p\", null, \"A problem with your API key prevents the map from rendering correctly. Please make sure the value of the \", /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"code\", null, \"APIProvider.apiKey\"), \" prop is correct. Check the error-message in the console for further details.\"));\n};\nfunction useCallbackRef() {\n    const [el, setEl] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const ref = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((value)=>setEl(value), [\n        setEl\n    ]);\n    return [\n        el,\n        ref\n    ];\n}\n/**\n * Hook to check if the Google Maps API is loaded\n */ function useApiIsLoaded() {\n    const status = useApiLoadingStatus();\n    return status === APILoadingStatus.LOADED;\n}\nfunction useForceUpdate() {\n    const [, forceUpdate] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useReducer)((x)=>x + 1, 0);\n    return forceUpdate;\n}\nfunction handleBoundsChange(map, ref) {\n    const center = map.getCenter();\n    const zoom = map.getZoom();\n    const heading = map.getHeading() || 0;\n    const tilt = map.getTilt() || 0;\n    const bounds = map.getBounds();\n    if (!center || !bounds || !Number.isFinite(zoom)) {\n        console.warn(\"[useTrackedCameraState] at least one of the values from the map \" + \"returned undefined. This is not expected to happen. Please \" + \"report an issue at https://github.com/visgl/react-google-maps/issues/new\");\n    }\n    // fixme: do we need the `undefined` cases for the camera-params? When are they used in the maps API?\n    Object.assign(ref.current, {\n        center: (center == null ? void 0 : center.toJSON()) || {\n            lat: 0,\n            lng: 0\n        },\n        zoom: zoom || 0,\n        heading: heading,\n        tilt: tilt\n    });\n}\n/**\n * Creates a mutable ref object to track the last known state of the map camera.\n * This is used in `useMapCameraParams` to reduce stuttering in normal operation\n * by avoiding updates of the map camera with values that have already been processed.\n */ function useTrackedCameraStateRef(map) {\n    const forceUpdate = useForceUpdate();\n    const ref = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({\n        center: {\n            lat: 0,\n            lng: 0\n        },\n        heading: 0,\n        tilt: 0,\n        zoom: 0\n    });\n    // Record camera state with every bounds_changed event dispatched by the map.\n    // This data is used to prevent feeding these values back to the\n    // map-instance when a typical \"controlled component\" setup (state variable is\n    // fed into and updated by the map).\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (!map) return;\n        const listener = google.maps.event.addListener(map, \"bounds_changed\", ()=>{\n            handleBoundsChange(map, ref);\n            // When an event is occured, we have to update during the next cycle.\n            // The application could decide to ignore the event and not update any\n            // camera props of the map, meaning that in that case we will have to\n            // 'undo' the change to the camera.\n            forceUpdate();\n        });\n        return ()=>listener.remove();\n    }, [\n        map,\n        forceUpdate\n    ]);\n    return ref;\n}\nconst _excluded$2 = [\n    \"id\",\n    \"defaultBounds\",\n    \"defaultCenter\",\n    \"defaultZoom\",\n    \"defaultHeading\",\n    \"defaultTilt\"\n];\n/**\n * The main hook takes care of creating map-instances and registering them in\n * the api-provider context.\n * @return a tuple of the map-instance created (or null) and the callback\n *   ref that will be used to pass the map-container into this hook.\n * @internal\n */ function useMapInstance(props, context) {\n    const apiIsLoaded = useApiIsLoaded();\n    const [map, setMap] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [container, containerRef] = useCallbackRef();\n    const cameraStateRef = useTrackedCameraStateRef(map);\n    const { id, defaultBounds, defaultCenter, defaultZoom, defaultHeading, defaultTilt } = props, mapOptions = _objectWithoutPropertiesLoose(props, _excluded$2);\n    // apply default camera props if available and not overwritten by controlled props\n    if (!mapOptions.center && defaultCenter) mapOptions.center = defaultCenter;\n    if (!mapOptions.zoom && Number.isFinite(defaultZoom)) mapOptions.zoom = defaultZoom;\n    if (!mapOptions.heading && Number.isFinite(defaultHeading)) mapOptions.heading = defaultHeading;\n    if (!mapOptions.tilt && Number.isFinite(defaultTilt)) mapOptions.tilt = defaultTilt;\n    for (const key of Object.keys(mapOptions))if (mapOptions[key] === undefined) delete mapOptions[key];\n    const savedMapStateRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)();\n    // create the map instance and register it in the context\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (!container || !apiIsLoaded) return;\n        const { addMapInstance, removeMapInstance } = context;\n        const mapId = props.mapId;\n        const newMap = new google.maps.Map(container, mapOptions);\n        setMap(newMap);\n        addMapInstance(newMap, id);\n        if (defaultBounds) {\n            newMap.fitBounds(defaultBounds);\n        }\n        // the savedMapState is used to restore the camera parameters when the mapId is changed\n        if (savedMapStateRef.current) {\n            const { mapId: savedMapId, cameraState: savedCameraState } = savedMapStateRef.current;\n            if (savedMapId !== mapId) {\n                newMap.setOptions(savedCameraState);\n            }\n        }\n        return ()=>{\n            savedMapStateRef.current = {\n                mapId,\n                // eslint-disable-next-line react-hooks/exhaustive-deps\n                cameraState: cameraStateRef.current\n            };\n            // remove all event-listeners to minimize memory-leaks\n            google.maps.event.clearInstanceListeners(newMap);\n            setMap(null);\n            removeMapInstance(id);\n        };\n    }, // some dependencies are ignored in the list below:\n    //  - defaultBounds and the default* camera props will only be used once, and\n    //    changes should be ignored\n    //  - mapOptions has special hooks that take care of updating the options\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [\n        container,\n        apiIsLoaded,\n        id,\n        props.mapId\n    ]);\n    return [\n        map,\n        containerRef,\n        cameraStateRef\n    ];\n}\nconst GoogleMapsContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\nconst Map = (props)=>{\n    const { children, id, className, style } = props;\n    const context = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(APIProviderContext);\n    const loadingStatus = useApiLoadingStatus();\n    if (!context) {\n        throw new Error(\"<Map> can only be used inside an <ApiProvider> component.\");\n    }\n    const [map, mapRef, cameraStateRef] = useMapInstance(props, context);\n    useMapCameraParams(map, cameraStateRef, props);\n    useMapEvents(map, props);\n    useMapOptions(map, props);\n    const isDeckGlControlled = useDeckGLCameraUpdate(map, props);\n    const isControlledExternally = !!props.controlled;\n    // disable interactions with the map for externally controlled maps\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (!map) return;\n        // fixme: this doesn't seem to belong here (and it's mostly there for convenience anyway).\n        //   The reasoning is that a deck.gl canvas will be put on top of the map, rendering\n        //   any default map controls pretty much useless\n        if (isDeckGlControlled) {\n            map.setOptions({\n                disableDefaultUI: true\n            });\n        }\n        // disable all control-inputs when the map is controlled externally\n        if (isDeckGlControlled || isControlledExternally) {\n            map.setOptions({\n                gestureHandling: \"none\",\n                keyboardShortcuts: false\n            });\n        }\n        return ()=>{\n            map.setOptions({\n                gestureHandling: props.gestureHandling,\n                keyboardShortcuts: props.keyboardShortcuts\n            });\n        };\n    }, [\n        map,\n        isDeckGlControlled,\n        isControlledExternally,\n        props.gestureHandling,\n        props.keyboardShortcuts\n    ]);\n    // setup a stable cameraOptions object that can be used as dependency\n    const center = props.center ? toLatLngLiteral(props.center) : null;\n    let lat = null;\n    let lng = null;\n    if (center && Number.isFinite(center.lat) && Number.isFinite(center.lng)) {\n        lat = center.lat;\n        lng = center.lng;\n    }\n    const cameraOptions = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        var _lat, _lng, _props$zoom, _props$heading, _props$tilt;\n        return {\n            center: {\n                lat: (_lat = lat) != null ? _lat : 0,\n                lng: (_lng = lng) != null ? _lng : 0\n            },\n            zoom: (_props$zoom = props.zoom) != null ? _props$zoom : 0,\n            heading: (_props$heading = props.heading) != null ? _props$heading : 0,\n            tilt: (_props$tilt = props.tilt) != null ? _props$tilt : 0\n        };\n    }, [\n        lat,\n        lng,\n        props.zoom,\n        props.heading,\n        props.tilt\n    ]);\n    // externally controlled mode: reject all camera changes that don't correspond to changes in props\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect)(()=>{\n        if (!map || !isControlledExternally) return;\n        map.moveCamera(cameraOptions);\n        const listener = map.addListener(\"bounds_changed\", ()=>{\n            map.moveCamera(cameraOptions);\n        });\n        return ()=>listener.remove();\n    }, [\n        map,\n        isControlledExternally,\n        cameraOptions\n    ]);\n    const combinedStyle = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>_extends({\n            width: \"100%\",\n            height: \"100%\",\n            // when using deckgl, the map should be sent to the back\n            zIndex: isDeckGlControlled ? -1 : 0\n        }, style), [\n        style,\n        isDeckGlControlled\n    ]);\n    if (loadingStatus === APILoadingStatus.AUTH_FAILURE) {\n        return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n            style: _extends({\n                position: \"relative\"\n            }, className ? {} : combinedStyle),\n            className: className\n        }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(AuthFailureMessage, null));\n    }\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", _extends({\n        ref: mapRef,\n        \"data-testid\": \"map\",\n        style: className ? undefined : combinedStyle,\n        className: className\n    }, id ? {\n        id\n    } : {}), map ? /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(GoogleMapsContext.Provider, {\n        value: {\n            map\n        }\n    }, children) : null);\n};\nMap.deckGLViewProps = true;\nfunction useMapsLibrary(name) {\n    const apiIsLoaded = useApiIsLoaded();\n    const ctx = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(APIProviderContext);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (!apiIsLoaded || !ctx) return;\n        // Trigger loading the libraries via our proxy-method.\n        // The returned promise is ignored, since importLibrary will update loadedLibraries\n        // list in the context, triggering a re-render.\n        void ctx.importLibrary(name);\n    }, [\n        apiIsLoaded,\n        ctx,\n        name\n    ]);\n    return (ctx == null ? void 0 : ctx.loadedLibraries[name]) || null;\n}\n/* eslint-disable complexity */ const AdvancedMarkerContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\nfunction useAdvancedMarker(props) {\n    var _useContext;\n    const [marker, setMarker] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [contentContainer, setContentContainer] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const map = (_useContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(GoogleMapsContext)) == null ? void 0 : _useContext.map;\n    const markerLibrary = useMapsLibrary(\"marker\");\n    const { children, className, onClick, onDrag, onDragStart, onDragEnd, collisionBehavior, draggable, position, title, zIndex } = props;\n    const numChilds = react__WEBPACK_IMPORTED_MODULE_0__.Children.count(children);\n    // create marker instance and add it to the map when map becomes available\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (!map || !markerLibrary) return;\n        const newMarker = new markerLibrary.AdvancedMarkerElement();\n        newMarker.map = map;\n        setMarker(newMarker);\n        // create container for marker content if there are children\n        if (numChilds > 0) {\n            const el = document.createElement(\"div\");\n            if (className) el.className = className;\n            newMarker.content = el;\n            setContentContainer(el);\n        }\n        return ()=>{\n            newMarker.map = null;\n            setMarker(null);\n            setContentContainer(null);\n        };\n    // We do not want to re-render the whole marker when the className changes\n    // because that causes a short flickering of the marker.\n    // The className update is handled in the useEffect below.\n    // Excluding the className from the dependency array onm purpose here\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [\n        map,\n        markerLibrary,\n        numChilds\n    ]);\n    // update className of advanced marker element\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (!contentContainer) return;\n        contentContainer.className = className != null ? className : \"\";\n    }, [\n        contentContainer,\n        className\n    ]);\n    // bind all marker events\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (!marker) return;\n        const gme = google.maps.event;\n        if (onClick) gme.addListener(marker, \"click\", onClick);\n        if (onDrag) gme.addListener(marker, \"drag\", onDrag);\n        if (onDragStart) gme.addListener(marker, \"dragstart\", onDragStart);\n        if (onDragEnd) gme.addListener(marker, \"dragend\", onDragEnd);\n        if ((onDrag || onDragStart || onDragEnd) && !draggable) {\n            console.warn(\"You need to set the marker to draggable to listen to drag-events.\");\n        }\n        const m = marker;\n        return ()=>{\n            gme.clearInstanceListeners(m);\n        };\n    }, [\n        marker,\n        draggable,\n        onClick,\n        onDragStart,\n        onDrag,\n        onDragEnd\n    ]);\n    // update other marker props when changed\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (!marker) return;\n        if (position !== undefined) marker.position = position;\n        if (draggable !== undefined) marker.gmpDraggable = draggable;\n        if (collisionBehavior !== undefined) marker.collisionBehavior = collisionBehavior;\n        if (zIndex !== undefined) marker.zIndex = zIndex;\n        if (typeof title === \"string\") marker.title = title;\n    }, [\n        marker,\n        position,\n        draggable,\n        collisionBehavior,\n        zIndex,\n        title\n    ]);\n    return [\n        marker,\n        contentContainer\n    ];\n}\nconst AdvancedMarker = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)((props, ref)=>{\n    const { children } = props;\n    const [marker, contentContainer] = useAdvancedMarker(props);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useImperativeHandle)(ref, ()=>marker, [\n        marker\n    ]);\n    if (!marker) {\n        return null;\n    }\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(AdvancedMarkerContext.Provider, {\n        value: {\n            marker\n        }\n    }, contentContainer !== null && /*#__PURE__*/ (0,react_dom__WEBPACK_IMPORTED_MODULE_1__.createPortal)(children, contentContainer));\n});\nfunction useAdvancedMarkerRef() {\n    const [marker, setMarker] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const refCallback = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((m)=>{\n        setMarker(m);\n    }, []);\n    return [\n        refCallback,\n        marker\n    ];\n}\nconst _excluded$1 = [\n    \"children\",\n    \"anchor\",\n    \"onCloseClick\"\n];\n/**\n * Component to render a Google Maps Info Window\n */ const InfoWindow = (props)=>{\n    var _useContext;\n    const { children, anchor, onCloseClick } = props, infoWindowOptions = _objectWithoutPropertiesLoose(props, _excluded$1);\n    const map = (_useContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(GoogleMapsContext)) == null ? void 0 : _useContext.map;\n    const infoWindowRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const [contentContainer, setContentContainer] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    // create infowindow once map is available\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (!map) return;\n        const newInfowindow = new google.maps.InfoWindow(infoWindowOptions);\n        // Add content to info window\n        const el = document.createElement(\"div\");\n        newInfowindow.setContent(el);\n        infoWindowRef.current = newInfowindow;\n        setContentContainer(el);\n        // Cleanup info window and event listeners on unmount\n        return ()=>{\n            google.maps.event.clearInstanceListeners(newInfowindow);\n            newInfowindow.close();\n            el.remove();\n            setContentContainer(null);\n        };\n    // `infoWindowOptions` is missing from dependencies:\n    //\n    // we don't want to re-render a whole new infowindow\n    // when the options change to prevent flickering.\n    // Update of infoWindow options is handled in the useEffect below.\n    //\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [\n        map,\n        children\n    ]);\n    // Update infoWindowOptions\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        var _infoWindowRef$curren;\n        (_infoWindowRef$curren = infoWindowRef.current) == null || _infoWindowRef$curren.setOptions(infoWindowOptions);\n    }, [\n        infoWindowOptions\n    ]);\n    // Handle the close click callback\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (!infoWindowRef.current) return;\n        let listener = null;\n        if (onCloseClick) {\n            listener = google.maps.event.addListener(infoWindowRef.current, \"closeclick\", onCloseClick);\n        }\n        return ()=>{\n            if (listener) listener.remove();\n        };\n    }, [\n        onCloseClick\n    ]);\n    // Open info window after content container is set\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        // anchor === null means an anchor is defined but not ready yet.\n        if (!contentContainer || !infoWindowRef.current || anchor === null) return;\n        const openOptions = {\n            map\n        };\n        if (anchor) {\n            openOptions.anchor = anchor;\n        }\n        infoWindowRef.current.open(openOptions);\n    }, [\n        contentContainer,\n        infoWindowRef,\n        anchor,\n        map\n    ]);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, contentContainer !== null && /*#__PURE__*/ (0,react_dom__WEBPACK_IMPORTED_MODULE_1__.createPortal)(children, contentContainer));\n};\nconst shownMessages = new Set();\nfunction logErrorOnce(...args) {\n    const key = JSON.stringify(args);\n    if (!shownMessages.has(key)) {\n        shownMessages.add(key);\n        console.error(...args);\n    }\n}\n/**\n * Retrieves a map-instance from the context. This is either an instance\n * identified by id or the parent map instance if no id is specified.\n * Returns null if neither can be found.\n */ const useMap = (id = null)=>{\n    const ctx = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(APIProviderContext);\n    const { map } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(GoogleMapsContext) || {};\n    if (ctx === null) {\n        logErrorOnce(\"useMap(): failed to retrieve APIProviderContext. \" + \"Make sure that the <APIProvider> component exists and that the \" + \"component you are calling `useMap()` from is a sibling of the \" + \"<APIProvider>.\");\n        return null;\n    }\n    const { mapInstances } = ctx;\n    // if an id is specified, the corresponding map or null is returned\n    if (id !== null) return mapInstances[id] || null;\n    // otherwise, return the closest ancestor\n    if (map) return map;\n    // finally, return the default map instance\n    return mapInstances[\"default\"] || null;\n};\n/**\n * Copy of the `google.maps.ControlPosition` constants.\n * They have to be duplicated here since we can't wait for the maps API to load to be able to use them.\n */ const ControlPosition = {\n    TOP_LEFT: 1,\n    TOP_CENTER: 2,\n    TOP: 2,\n    TOP_RIGHT: 3,\n    LEFT_CENTER: 4,\n    LEFT_TOP: 5,\n    LEFT: 5,\n    LEFT_BOTTOM: 6,\n    RIGHT_TOP: 7,\n    RIGHT: 7,\n    RIGHT_CENTER: 8,\n    RIGHT_BOTTOM: 9,\n    BOTTOM_LEFT: 10,\n    BOTTOM_CENTER: 11,\n    BOTTOM: 11,\n    BOTTOM_RIGHT: 12,\n    CENTER: 13,\n    BLOCK_START_INLINE_START: 14,\n    BLOCK_START_INLINE_CENTER: 15,\n    BLOCK_START_INLINE_END: 16,\n    INLINE_START_BLOCK_CENTER: 17,\n    INLINE_START_BLOCK_START: 18,\n    INLINE_START_BLOCK_END: 19,\n    INLINE_END_BLOCK_START: 20,\n    INLINE_END_BLOCK_CENTER: 21,\n    INLINE_END_BLOCK_END: 22,\n    BLOCK_END_INLINE_START: 23,\n    BLOCK_END_INLINE_CENTER: 24,\n    BLOCK_END_INLINE_END: 25\n};\nconst MapControl = ({ children, position })=>{\n    const controlContainer = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>document.createElement(\"div\"), []);\n    const map = useMap();\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (!map) return;\n        const controls = map.controls[position];\n        controls.push(controlContainer);\n        return ()=>{\n            const index = controls.getArray().indexOf(controlContainer);\n            controls.removeAt(index);\n        };\n    }, [\n        controlContainer,\n        map,\n        position\n    ]);\n    return /*#__PURE__*/ (0,react_dom__WEBPACK_IMPORTED_MODULE_1__.createPortal)(children, controlContainer);\n};\nconst _excluded = [\n    \"onClick\",\n    \"onDrag\",\n    \"onDragStart\",\n    \"onDragEnd\",\n    \"onMouseOver\",\n    \"onMouseOut\"\n];\nfunction useMarker(props) {\n    var _useContext;\n    const [marker, setMarker] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const map = (_useContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(GoogleMapsContext)) == null ? void 0 : _useContext.map;\n    const { onClick, onDrag, onDragStart, onDragEnd, onMouseOver, onMouseOut } = props, markerOptions = _objectWithoutPropertiesLoose(props, _excluded);\n    const { position, draggable } = markerOptions;\n    // create marker instance and add to the map once the map is available\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (!map) {\n            if (map === undefined) console.error(\"<Marker> has to be inside a Map component.\");\n            return;\n        }\n        const newMarker = new google.maps.Marker(markerOptions);\n        newMarker.setMap(map);\n        setMarker(newMarker);\n        return ()=>{\n            newMarker.setMap(null);\n            setMarker(null);\n        };\n    // We do not want to re-render the whole marker when the options change.\n    // Marker options update is handled in a useEffect below.\n    // Excluding markerOptions from dependency array on purpose here.\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [\n        map\n    ]);\n    // attach and re-attach event-handlers when any of the properties change\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (!marker) return;\n        const m = marker;\n        // Add event listeners\n        const gme = google.maps.event;\n        if (onClick) gme.addListener(m, \"click\", onClick);\n        if (onDrag) gme.addListener(m, \"drag\", onDrag);\n        if (onDragStart) gme.addListener(m, \"dragstart\", onDragStart);\n        if (onDragEnd) gme.addListener(m, \"dragend\", onDragEnd);\n        if (onMouseOver) gme.addListener(m, \"mouseover\", onMouseOver);\n        if (onMouseOut) gme.addListener(m, \"mouseout\", onMouseOut);\n        marker.setDraggable(Boolean(draggable));\n        return ()=>{\n            gme.clearInstanceListeners(m);\n        };\n    }, [\n        marker,\n        draggable,\n        onClick,\n        onDrag,\n        onDragStart,\n        onDragEnd,\n        onMouseOver,\n        onMouseOut\n    ]);\n    // update markerOptions (note the dependencies aren't properly checked\n    // here, we just assume that setOptions is smart enough to not waste a\n    // lot of time updating values that didn't change)\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (!marker) return;\n        if (markerOptions) marker.setOptions(markerOptions);\n    }, [\n        marker,\n        markerOptions\n    ]);\n    // update position when changed\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        // Should not update position when draggable\n        if (draggable || !position || !marker) return;\n        marker.setPosition(position);\n    }, [\n        draggable,\n        position,\n        marker\n    ]);\n    return marker;\n}\n/**\n * Component to render a Google Maps Marker on a map\n */ const Marker = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)((props, ref)=>{\n    const marker = useMarker(props);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useImperativeHandle)(ref, ()=>marker, [\n        marker\n    ]);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null);\n});\nfunction useMarkerRef() {\n    const [marker, setMarker] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const refCallback = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((m)=>{\n        setMarker(m);\n    }, []);\n    return [\n        refCallback,\n        marker\n    ];\n}\n/**\n * Component to render a google maps marker Pin View\n */ const Pin = (props)=>{\n    var _useContext;\n    const advancedMarker = (_useContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(AdvancedMarkerContext)) == null ? void 0 : _useContext.marker;\n    const glyphContainer = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>document.createElement(\"div\"), []);\n    // Create Pin View instance\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (!advancedMarker) {\n            if (advancedMarker === undefined) {\n                console.error(\"The <Pin> component can only be used inside <AdvancedMarker>.\");\n            }\n            return;\n        }\n        if (props.glyph && props.children) {\n            logErrorOnce(\"The <Pin> component only uses children to render the glyph if both the glyph property and children are present.\");\n        }\n        if (react__WEBPACK_IMPORTED_MODULE_0__.Children.count(props.children) > 1) {\n            logErrorOnce(\"Passing multiple children to the <Pin> component might lead to unexpected results.\");\n        }\n        const pinViewOptions = _extends({}, props);\n        const pinElement = new google.maps.marker.PinElement(pinViewOptions);\n        // Set glyph to glyph container if children are present (rendered via portal).\n        // If both props.glyph and props.children are present, props.children takes priority.\n        if (props.children) {\n            pinElement.glyph = glyphContainer;\n        }\n        // Set content of Advanced Marker View to the Pin View element\n        advancedMarker.content = pinElement.element;\n    }, [\n        advancedMarker,\n        glyphContainer,\n        props\n    ]);\n    return /*#__PURE__*/ (0,react_dom__WEBPACK_IMPORTED_MODULE_1__.createPortal)(props.children, glyphContainer);\n};\nconst mapLinear = (x, a1, a2, b1, b2)=>b1 + (x - a1) * (b2 - b1) / (a2 - a1);\nconst getMapMaxTilt = (zoom)=>{\n    if (zoom <= 10) {\n        return 30;\n    }\n    if (zoom >= 15.5) {\n        return 67.5;\n    }\n    // range [10...14]\n    if (zoom <= 14) {\n        return mapLinear(zoom, 10, 14, 30, 45);\n    }\n    // range [14...15.5]\n    return mapLinear(zoom, 14, 15.5, 45, 67.5);\n};\n/**\n * Function to limit the tilt range of the google maps map when updating the view state\n */ // eslint-disable-next-line @typescript-eslint/no-explicit-any\nconst limitTiltRange = ({ viewState })=>{\n    const pitch = viewState.pitch;\n    const gmZoom = viewState.zoom + 1;\n    const maxTilt = getMapMaxTilt(gmZoom);\n    return _extends({}, viewState, {\n        fovy: 25,\n        pitch: Math.min(maxTilt, pitch)\n    });\n};\n //# sourceMappingURL=index.modern.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0B2aXMuZ2wvcmVhY3QtZ29vZ2xlLW1hcHMvZGlzdC9pbmRleC5tb2Rlcm4ubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBcUs7QUFDNUg7QUFDQztBQUUxQyxTQUFTYyxhQUFhQyxDQUFDLEVBQUVDLENBQUM7SUFDeEIsSUFBSSxZQUFZLE9BQU9ELEtBQUssQ0FBQ0EsR0FBRyxPQUFPQTtJQUN2QyxJQUFJRSxJQUFJRixDQUFDLENBQUNHLE9BQU9DLFdBQVcsQ0FBQztJQUM3QixJQUFJLEtBQUssTUFBTUYsR0FBRztRQUNoQixJQUFJRyxJQUFJSCxFQUFFSSxJQUFJLENBQUNOLEdBQUdDLEtBQUs7UUFDdkIsSUFBSSxZQUFZLE9BQU9JLEdBQUcsT0FBT0E7UUFDakMsTUFBTSxJQUFJRSxVQUFVO0lBQ3RCO0lBQ0EsT0FBTyxDQUFDLGFBQWFOLElBQUlPLFNBQVNDLE1BQUssRUFBR1Q7QUFDNUM7QUFDQSxTQUFTVSxlQUFlVixDQUFDO0lBQ3ZCLElBQUlLLElBQUlOLGFBQWFDLEdBQUc7SUFDeEIsT0FBTyxZQUFZLE9BQU9LLElBQUlBLElBQUlHLE9BQU9IO0FBQzNDO0FBQ0EsU0FBU007SUFDUEEsV0FBV0MsT0FBT0MsTUFBTSxHQUFHRCxPQUFPQyxNQUFNLENBQUNDLElBQUksS0FBSyxTQUFVQyxNQUFNO1FBQ2hFLElBQUssSUFBSVYsSUFBSSxHQUFHQSxJQUFJVyxVQUFVQyxNQUFNLEVBQUVaLElBQUs7WUFDekMsSUFBSWEsU0FBU0YsU0FBUyxDQUFDWCxFQUFFO1lBQ3pCLElBQUssSUFBSWMsT0FBT0QsT0FBUTtnQkFDdEIsSUFBSU4sT0FBT1EsU0FBUyxDQUFDQyxjQUFjLENBQUNmLElBQUksQ0FBQ1ksUUFBUUMsTUFBTTtvQkFDckRKLE1BQU0sQ0FBQ0ksSUFBSSxHQUFHRCxNQUFNLENBQUNDLElBQUk7Z0JBQzNCO1lBQ0Y7UUFDRjtRQUNBLE9BQU9KO0lBQ1Q7SUFDQSxPQUFP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QUFJQyxJQUFJQyxLQUFPRCxLQUFLLENBQUMvSSxJQUFJNkksRUFBQyxJQUFNRyxDQUFBQSxLQUFLRCxFQUFDLElBQU1ELENBQUFBLEtBQUtELEVBQUM7QUFDNUUsTUFBTUksZ0JBQWdCdlAsQ0FBQUE7SUFDcEIsSUFBSUEsUUFBUSxJQUFJO1FBQ2QsT0FBTztJQUNUO0lBQ0EsSUFBSUEsUUFBUSxNQUFNO1FBQ2hCLE9BQU87SUFDVDtJQUNBLGtCQUFrQjtJQUNsQixJQUFJQSxRQUFRLElBQUk7UUFDZCxPQUFPa1AsVUFBVWxQLE1BQU0sSUFBSSxJQUFJLElBQUk7SUFDckM7SUFDQSxvQkFBb0I7SUFDcEIsT0FBT2tQLFVBQVVsUCxNQUFNLElBQUksTUFBTSxJQUFJO0FBQ3ZDO0FBQ0E7O0NBRUMsR0FDRCw4REFBOEQ7QUFDOUQsTUFBTXdQLGlCQUFpQixDQUFDLEVBQ3RCM0wsU0FBUyxFQUNWO0lBQ0MsTUFBTUssUUFBUUwsVUFBVUssS0FBSztJQUM3QixNQUFNdUwsU0FBUzVMLFVBQVU3RCxJQUFJLEdBQUc7SUFDaEMsTUFBTTBQLFVBQVVILGNBQWNFO0lBQzlCLE9BQU9yWSxTQUFTLENBQUMsR0FBR3lNLFdBQVc7UUFDN0I4TCxNQUFNO1FBQ056TCxPQUFPMEwsS0FBS0MsR0FBRyxDQUFDSCxTQUFTeEw7SUFDM0I7QUFDRjtBQUVtVixDQUNuVix5Q0FBeUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcm9udC1lbmQvLi4vbm9kZV9tb2R1bGVzL0B2aXMuZ2wvcmVhY3QtZ29vZ2xlLW1hcHMvZGlzdC9pbmRleC5tb2Rlcm4ubWpzPzNlZTkiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlYWN0LCB7IHVzZVN0YXRlLCB1c2VSZWR1Y2VyLCB1c2VNZW1vLCB1c2VDYWxsYmFjaywgdXNlRWZmZWN0LCB1c2VSZWYsIHVzZUNvbnRleHQsIHVzZUxheW91dEVmZmVjdCwgZm9yd2FyZFJlZiwgdXNlSW1wZXJhdGl2ZUhhbmRsZSwgQ2hpbGRyZW4gfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBjcmVhdGVQb3J0YWwgfSBmcm9tICdyZWFjdC1kb20nO1xuaW1wb3J0IGlzRGVlcEVxdWFsIGZyb20gJ2Zhc3QtZGVlcC1lcXVhbCc7XG5cbmZ1bmN0aW9uIF90b1ByaW1pdGl2ZSh0LCByKSB7XG4gIGlmIChcIm9iamVjdFwiICE9IHR5cGVvZiB0IHx8ICF0KSByZXR1cm4gdDtcbiAgdmFyIGUgPSB0W1N5bWJvbC50b1ByaW1pdGl2ZV07XG4gIGlmICh2b2lkIDAgIT09IGUpIHtcbiAgICB2YXIgaSA9IGUuY2FsbCh0LCByIHx8IFwiZGVmYXVsdFwiKTtcbiAgICBpZiAoXCJvYmplY3RcIiAhPSB0eXBlb2YgaSkgcmV0dXJuIGk7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkBAdG9QcmltaXRpdmUgbXVzdCByZXR1cm4gYSBwcmltaXRpdmUgdmFsdWUuXCIpO1xuICB9XG4gIHJldHVybiAoXCJzdHJpbmdcIiA9PT0gciA/IFN0cmluZyA6IE51bWJlcikodCk7XG59XG5mdW5jdGlvbiBfdG9Qcm9wZXJ0eUtleSh0KSB7XG4gIHZhciBpID0gX3RvUHJpbWl0aXZlKHQsIFwic3RyaW5nXCIpO1xuICByZXR1cm4gXCJzeW1ib2xcIiA9PSB0eXBlb2YgaSA/IGkgOiBTdHJpbmcoaSk7XG59XG5mdW5jdGlvbiBfZXh0ZW5kcygpIHtcbiAgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduID8gT2JqZWN0LmFzc2lnbi5iaW5kKCkgOiBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07XG4gICAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7XG4gICAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9O1xuICByZXR1cm4gX2V4dGVuZHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpIHtcbiAgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307XG4gIHZhciB0YXJnZXQgPSB7fTtcbiAgdmFyIHNvdXJjZUtleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpO1xuICB2YXIga2V5LCBpO1xuICBmb3IgKGkgPSAwOyBpIDwgc291cmNlS2V5cy5sZW5ndGg7IGkrKykge1xuICAgIGtleSA9IHNvdXJjZUtleXNbaV07XG4gICAgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTtcbiAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICB9XG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbmNvbnN0IEFQSUxvYWRpbmdTdGF0dXMgPSB7XG4gIE5PVF9MT0FERUQ6ICdOT1RfTE9BREVEJyxcbiAgTE9BRElORzogJ0xPQURJTkcnLFxuICBMT0FERUQ6ICdMT0FERUQnLFxuICBGQUlMRUQ6ICdGQUlMRUQnLFxuICBBVVRIX0ZBSUxVUkU6ICdBVVRIX0ZBSUxVUkUnXG59O1xuXG5jb25zdCBNQVBTX0FQSV9CQVNFX1VSTCA9ICdodHRwczovL21hcHMuZ29vZ2xlYXBpcy5jb20vbWFwcy9hcGkvanMnO1xuLyoqXG4gKiBBIEdvb2dsZU1hcHNBcGlMb2FkZXIgdG8gcmVsaWFibHkgbG9hZCBhbmQgdW5sb2FkIHRoZSBHb29nbGUgTWFwcyBKYXZhU2NyaXB0IEFQSS5cbiAqXG4gKiBUaGUgYWN0dWFsIGxvYWRpbmcgYW5kIHVubG9hZGluZyBpcyBkZWxheWVkIGludG8gdGhlIG1pY3JvdGFzayBxdWV1ZSwgdG9cbiAqIGFsbG93IHVzaW5nIHRoZSBBUEkgaW4gYW4gdXNlRWZmZWN0IGhvb2ssIHdpdGhvdXQgd29ycnlpbmcgYWJvdXQgbXVsdGlwbGUgQVBJIGxvYWRzLlxuICovXG5jbGFzcyBHb29nbGVNYXBzQXBpTG9hZGVyIHtcbiAgLyoqXG4gICAqIExvYWRzIHRoZSBHb29nbGUgTWFwcyBBUEkgd2l0aCB0aGUgc3BlY2lmaWVkIHBhcmFtZXRlcnMuXG4gICAqIFNpbmNlIHRoZSBNYXBzIGxpYnJhcnkgY2FuIG9ubHkgYmUgbG9hZGVkIG9uY2UgcGVyIHBhZ2UsIHRoaXMgd2lsbFxuICAgKiBwcm9kdWNlIGEgd2FybmluZyB3aGVuIGNhbGxlZCBtdWx0aXBsZSB0aW1lcyB3aXRoIGRpZmZlcmVudFxuICAgKiBwYXJhbWV0ZXJzLlxuICAgKlxuICAgKiBUaGUgcmV0dXJuZWQgcHJvbWlzZSByZXNvbHZlcyB3aGVuIGxvYWRpbmcgY29tcGxldGVzXG4gICAqIGFuZCByZWplY3RzIGluIGNhc2Ugb2YgYW4gZXJyb3Igb3Igd2hlbiB0aGUgbG9hZGluZyB3YXMgYWJvcnRlZC5cbiAgICovXG4gIHN0YXRpYyBhc3luYyBsb2FkKHBhcmFtcywgb25Mb2FkaW5nU3RhdHVzQ2hhbmdlKSB7XG4gICAgdmFyIF93aW5kb3ckZ29vZ2xlO1xuICAgIGNvbnN0IGxpYnJhcmllcyA9IHBhcmFtcy5saWJyYXJpZXMgPyBwYXJhbXMubGlicmFyaWVzLnNwbGl0KCcsJykgOiBbXTtcbiAgICBjb25zdCBzZXJpYWxpemVkUGFyYW1zID0gdGhpcy5zZXJpYWxpemVQYXJhbXMocGFyYW1zKTtcbiAgICAvLyBub3RlOiBpZiBnb29nbGUubWFwcy5pbXBvcnRMaWJyYXJ5IHdhcyBkZWZpbmVkIGV4dGVybmFsbHksIHRoZSBwYXJhbXNcbiAgICAvLyAgIHdpbGwgYmUgaWdub3JlZC4gSWYgaXQgd2FzIGRlZmluZWQgYnkgYSBwcmV2aW91cyBjYWxsIHRvIHRoaXNcbiAgICAvLyAgIG1ldGhvZCwgd2Ugd2lsbCBjaGVjayB0aGF0IHRoZSBrZXkgYW5kIG90aGVyIHBhcmFtZXRlcnMgaGF2ZSBub3QgYmVlblxuICAgIC8vICAgY2hhbmdlZCBpbiBiZXR3ZWVuIGNhbGxzLlxuICAgIGlmICghKChfd2luZG93JGdvb2dsZSA9IHdpbmRvdy5nb29nbGUpICE9IG51bGwgJiYgKF93aW5kb3ckZ29vZ2xlID0gX3dpbmRvdyRnb29nbGUubWFwcykgIT0gbnVsbCAmJiBfd2luZG93JGdvb2dsZS5pbXBvcnRMaWJyYXJ5KSkge1xuICAgICAgdGhpcy5zZXJpYWxpemVkQXBpUGFyYW1zID0gc2VyaWFsaXplZFBhcmFtcztcbiAgICAgIHRoaXMuaW5pdEltcG9ydExpYnJhcnkocGFyYW1zLCBvbkxvYWRpbmdTdGF0dXNDaGFuZ2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBpZiBzZXJpYWxpemVkQXBpUGFyYW1zIGlzbid0IGRlZmluZWQgdGhlIGxpYnJhcnkgd2FzIGxvYWRlZCBleHRlcm5hbGx5XG4gICAgICAvLyBhbmQgd2UgY2FuIG9ubHkgYXNzdW1lIHRoYXQgd2VudCBhbHJpZ2h0LlxuICAgICAgaWYgKCF0aGlzLnNlcmlhbGl6ZWRBcGlQYXJhbXMpIHtcbiAgICAgICAgdGhpcy5sb2FkaW5nU3RhdHVzID0gQVBJTG9hZGluZ1N0YXR1cy5MT0FERUQ7XG4gICAgICB9XG4gICAgICBvbkxvYWRpbmdTdGF0dXNDaGFuZ2UodGhpcy5sb2FkaW5nU3RhdHVzKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuc2VyaWFsaXplZEFwaVBhcmFtcyAmJiB0aGlzLnNlcmlhbGl6ZWRBcGlQYXJhbXMgIT09IHNlcmlhbGl6ZWRQYXJhbXMpIHtcbiAgICAgIGNvbnNvbGUud2FybihgVGhlIG1hcHMgQVBJIGhhcyBhbHJlYWR5IGJlZW4gbG9hZGVkIHdpdGggZGlmZmVyZW50IGAgKyBgcGFyYW1ldGVycyBhbmQgd2lsbCBub3QgYmUgbG9hZGVkIGFnYWluLiBSZWZyZXNoIHRoZSBwYWdlIGZvciBgICsgYG5ldyB2YWx1ZXMgdG8gaGF2ZSBlZmZlY3QuYCk7XG4gICAgfVxuICAgIGZvciAoY29uc3QgbGliIG9mIFsnbWFwcycsIC4uLmxpYnJhcmllc10pIHtcbiAgICAgIGF3YWl0IGdvb2dsZS5tYXBzLmltcG9ydExpYnJhcnkobGliKTtcbiAgICB9XG4gIH1cbiAgc3RhdGljIHNlcmlhbGl6ZVBhcmFtcyhwYXJhbXMpIHtcbiAgICByZXR1cm4gW3BhcmFtcy52LCBwYXJhbXMua2V5LCBwYXJhbXMubGFuZ3VhZ2UsIHBhcmFtcy5yZWdpb24sIHBhcmFtcy5hdXRoUmVmZXJyZXJQb2xpY3ksIHBhcmFtcy5zb2x1dGlvbkNoYW5uZWxdLmpvaW4oJy8nKTtcbiAgfVxuICBzdGF0aWMgaW5pdEltcG9ydExpYnJhcnkocGFyYW1zLCBvbkxvYWRpbmdTdGF0dXNDaGFuZ2UpIHtcbiAgICBpZiAoIXdpbmRvdy5nb29nbGUpIHdpbmRvdy5nb29nbGUgPSB7fTtcbiAgICBpZiAoIXdpbmRvdy5nb29nbGUubWFwcykgd2luZG93Lmdvb2dsZS5tYXBzID0ge307XG4gICAgaWYgKHdpbmRvdy5nb29nbGUubWFwc1snaW1wb3J0TGlicmFyeSddKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ2luaXRJbXBvcnRMaWJyYXJ5IGNhbiBvbmx5IGJlIGNhbGxlZCBvbmNlLicsIHBhcmFtcyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCBhcGlQcm9taXNlID0gbnVsbDtcbiAgICBjb25zdCBsb2FkQXBpID0gbGlicmFyeSA9PiB7XG4gICAgICBpZiAoYXBpUHJvbWlzZSkgcmV0dXJuIGFwaVByb21pc2U7XG4gICAgICBhcGlQcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICB2YXIgX2RvY3VtZW50JHF1ZXJ5U2VsZWN0O1xuICAgICAgICBjb25zdCBzY3JpcHRFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0Jyk7XG4gICAgICAgIGNvbnN0IHVybFBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoKTtcbiAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMocGFyYW1zKSkge1xuICAgICAgICAgIGNvbnN0IHVybFBhcmFtTmFtZSA9IGtleS5yZXBsYWNlKC9bQS1aXS9nLCB0ID0+ICdfJyArIHRbMF0udG9Mb3dlckNhc2UoKSk7XG4gICAgICAgICAgdXJsUGFyYW1zLnNldCh1cmxQYXJhbU5hbWUsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICB1cmxQYXJhbXMuc2V0KCdsaWJyYXJpZXMnLCBsaWJyYXJ5KTtcbiAgICAgICAgdXJsUGFyYW1zLnNldCgnbG9hZGluZycsICdhc3luYycpO1xuICAgICAgICB1cmxQYXJhbXMuc2V0KCdjYWxsYmFjaycsICdfX2dvb2dsZU1hcHNDYWxsYmFja19fJyk7XG4gICAgICAgIHNjcmlwdEVsZW1lbnQuYXN5bmMgPSB0cnVlO1xuICAgICAgICBzY3JpcHRFbGVtZW50LnNyYyA9IE1BUFNfQVBJX0JBU0VfVVJMICsgYD9gICsgdXJsUGFyYW1zLnRvU3RyaW5nKCk7XG4gICAgICAgIHdpbmRvdy5fX2dvb2dsZU1hcHNDYWxsYmFja19fID0gKCkgPT4ge1xuICAgICAgICAgIHRoaXMubG9hZGluZ1N0YXR1cyA9IEFQSUxvYWRpbmdTdGF0dXMuTE9BREVEO1xuICAgICAgICAgIG9uTG9hZGluZ1N0YXR1c0NoYW5nZSh0aGlzLmxvYWRpbmdTdGF0dXMpO1xuICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgfTtcbiAgICAgICAgd2luZG93LmdtX2F1dGhGYWlsdXJlID0gKCkgPT4ge1xuICAgICAgICAgIHRoaXMubG9hZGluZ1N0YXR1cyA9IEFQSUxvYWRpbmdTdGF0dXMuQVVUSF9GQUlMVVJFO1xuICAgICAgICAgIG9uTG9hZGluZ1N0YXR1c0NoYW5nZSh0aGlzLmxvYWRpbmdTdGF0dXMpO1xuICAgICAgICB9O1xuICAgICAgICBzY3JpcHRFbGVtZW50Lm9uZXJyb3IgPSAoKSA9PiB7XG4gICAgICAgICAgdGhpcy5sb2FkaW5nU3RhdHVzID0gQVBJTG9hZGluZ1N0YXR1cy5GQUlMRUQ7XG4gICAgICAgICAgb25Mb2FkaW5nU3RhdHVzQ2hhbmdlKHRoaXMubG9hZGluZ1N0YXR1cyk7XG4gICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcignVGhlIEdvb2dsZSBNYXBzIEphdmFTY3JpcHQgQVBJIGNvdWxkIG5vdCBsb2FkLicpKTtcbiAgICAgICAgfTtcbiAgICAgICAgc2NyaXB0RWxlbWVudC5ub25jZSA9ICgoX2RvY3VtZW50JHF1ZXJ5U2VsZWN0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcignc2NyaXB0W25vbmNlXScpKSA9PSBudWxsID8gdm9pZCAwIDogX2RvY3VtZW50JHF1ZXJ5U2VsZWN0Lm5vbmNlKSB8fCAnJztcbiAgICAgICAgdGhpcy5sb2FkaW5nU3RhdHVzID0gQVBJTG9hZGluZ1N0YXR1cy5MT0FESU5HO1xuICAgICAgICBvbkxvYWRpbmdTdGF0dXNDaGFuZ2UodGhpcy5sb2FkaW5nU3RhdHVzKTtcbiAgICAgICAgZG9jdW1lbnQuaGVhZC5hcHBlbmQoc2NyaXB0RWxlbWVudCk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBhcGlQcm9taXNlO1xuICAgIH07XG4gICAgLy8gZm9yIHRoZSBmaXJzdCBsb2FkLCB3ZSBkZWNsYXJlIGFuIGltcG9ydExpYnJhcnkgZnVuY3Rpb24gdGhhdCB3aWxsXG4gICAgLy8gYmUgb3ZlcndyaXR0ZW4gb25jZSB0aGUgYXBpIGlzIGxvYWRlZC5cbiAgICBnb29nbGUubWFwcy5pbXBvcnRMaWJyYXJ5ID0gbGlicmFyeU5hbWUgPT4gbG9hZEFwaShsaWJyYXJ5TmFtZSkudGhlbigoKSA9PiBnb29nbGUubWFwcy5pbXBvcnRMaWJyYXJ5KGxpYnJhcnlOYW1lKSk7XG4gIH1cbn1cbkdvb2dsZU1hcHNBcGlMb2FkZXIubG9hZGluZ1N0YXR1cyA9IEFQSUxvYWRpbmdTdGF0dXMuTk9UX0xPQURFRDtcbkdvb2dsZU1hcHNBcGlMb2FkZXIuc2VyaWFsaXplZEFwaVBhcmFtcyA9IHZvaWQgMDtcblxuY29uc3QgX2V4Y2x1ZGVkJDMgPSBbXCJvbkxvYWRcIiwgXCJhcGlLZXlcIiwgXCJ2ZXJzaW9uXCIsIFwibGlicmFyaWVzXCJdLFxuICBfZXhjbHVkZWQyID0gW1wiY2hpbGRyZW5cIl07XG5jb25zdCBBUElQcm92aWRlckNvbnRleHQgPSBSZWFjdC5jcmVhdGVDb250ZXh0KG51bGwpO1xuLyoqXG4gKiBsb2NhbCBob29rIHRvIHNldCB1cCB0aGUgbWFwLWluc3RhbmNlIG1hbmFnZW1lbnQgY29udGV4dC5cbiAqL1xuZnVuY3Rpb24gdXNlTWFwSW5zdGFuY2VzKCkge1xuICBjb25zdCBbbWFwSW5zdGFuY2VzLCBzZXRNYXBJbnN0YW5jZXNdID0gdXNlU3RhdGUoe30pO1xuICBjb25zdCBhZGRNYXBJbnN0YW5jZSA9IChtYXBJbnN0YW5jZSwgaWQgPSAnZGVmYXVsdCcpID0+IHtcbiAgICBzZXRNYXBJbnN0YW5jZXMoaW5zdGFuY2VzID0+IF9leHRlbmRzKHt9LCBpbnN0YW5jZXMsIHtcbiAgICAgIFtpZF06IG1hcEluc3RhbmNlXG4gICAgfSkpO1xuICB9O1xuICBjb25zdCByZW1vdmVNYXBJbnN0YW5jZSA9IChpZCA9ICdkZWZhdWx0JykgPT4ge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgICBzZXRNYXBJbnN0YW5jZXMoX3JlZiA9PiB7XG4gICAgICBsZXQgcmVtYWluaW5nID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UoX3JlZiwgW2lkXS5tYXAoX3RvUHJvcGVydHlLZXkpKTtcbiAgICAgIHJldHVybiByZW1haW5pbmc7XG4gICAgfSk7XG4gIH07XG4gIGNvbnN0IGNsZWFyTWFwSW5zdGFuY2VzID0gKCkgPT4ge1xuICAgIHNldE1hcEluc3RhbmNlcyh7fSk7XG4gIH07XG4gIHJldHVybiB7XG4gICAgbWFwSW5zdGFuY2VzLFxuICAgIGFkZE1hcEluc3RhbmNlLFxuICAgIHJlbW92ZU1hcEluc3RhbmNlLFxuICAgIGNsZWFyTWFwSW5zdGFuY2VzXG4gIH07XG59XG4vKipcbiAqIGxvY2FsIGhvb2sgdG8gaGFuZGxlIHRoZSBsb2FkaW5nIG9mIHRoZSBtYXBzIEFQSSwgcmV0dXJucyB0aGUgY3VycmVudCBsb2FkaW5nIHN0YXR1c1xuICogQHBhcmFtIHByb3BzXG4gKi9cbmZ1bmN0aW9uIHVzZUdvb2dsZU1hcHNBcGlMb2FkZXIocHJvcHMpIHtcbiAgY29uc3Qge1xuICAgICAgb25Mb2FkLFxuICAgICAgYXBpS2V5LFxuICAgICAgdmVyc2lvbixcbiAgICAgIGxpYnJhcmllcyA9IFtdXG4gICAgfSA9IHByb3BzLFxuICAgIG90aGVyQXBpUGFyYW1zID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UocHJvcHMsIF9leGNsdWRlZCQzKTtcbiAgY29uc3QgW3N0YXR1cywgc2V0U3RhdHVzXSA9IHVzZVN0YXRlKEdvb2dsZU1hcHNBcGlMb2FkZXIubG9hZGluZ1N0YXR1cyk7XG4gIGNvbnN0IFtsb2FkZWRMaWJyYXJpZXMsIGFkZExvYWRlZExpYnJhcnldID0gdXNlUmVkdWNlcigobG9hZGVkTGlicmFyaWVzLCBhY3Rpb24pID0+IHtcbiAgICByZXR1cm4gX2V4dGVuZHMoe30sIGxvYWRlZExpYnJhcmllcywge1xuICAgICAgW2FjdGlvbi5uYW1lXTogYWN0aW9uLnZhbHVlXG4gICAgfSk7XG4gIH0sIHt9KTtcbiAgY29uc3QgbGlicmFyaWVzU3RyaW5nID0gdXNlTWVtbygoKSA9PiBsaWJyYXJpZXMgPT0gbnVsbCA/IHZvaWQgMCA6IGxpYnJhcmllcy5qb2luKCcsJyksIFtsaWJyYXJpZXNdKTtcbiAgY29uc3Qgc2VyaWFsaXplZFBhcmFtcyA9IHVzZU1lbW8oKCkgPT4gSlNPTi5zdHJpbmdpZnkoX2V4dGVuZHMoe1xuICAgIGFwaUtleSxcbiAgICB2ZXJzaW9uXG4gIH0sIG90aGVyQXBpUGFyYW1zKSksIFthcGlLZXksIHZlcnNpb24sIG90aGVyQXBpUGFyYW1zXSk7XG4gIGNvbnN0IGltcG9ydExpYnJhcnkgPSB1c2VDYWxsYmFjayhhc3luYyBuYW1lID0+IHtcbiAgICB2YXIgX2dvb2dsZTtcbiAgICBpZiAobG9hZGVkTGlicmFyaWVzW25hbWVdKSB7XG4gICAgICByZXR1cm4gbG9hZGVkTGlicmFyaWVzW25hbWVdO1xuICAgIH1cbiAgICBpZiAoISgoX2dvb2dsZSA9IGdvb2dsZSkgIT0gbnVsbCAmJiAoX2dvb2dsZSA9IF9nb29nbGUubWFwcykgIT0gbnVsbCAmJiBfZ29vZ2xlLmltcG9ydExpYnJhcnkpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1thcGktcHJvdmlkZXItaW50ZXJuYWxdIGltcG9ydExpYnJhcnkgd2FzIGNhbGxlZCBiZWZvcmUgJyArICdnb29nbGUubWFwcy5pbXBvcnRMaWJyYXJ5IHdhcyBkZWZpbmVkLicpO1xuICAgIH1cbiAgICBjb25zdCByZXMgPSBhd2FpdCB3aW5kb3cuZ29vZ2xlLm1hcHMuaW1wb3J0TGlicmFyeShuYW1lKTtcbiAgICBhZGRMb2FkZWRMaWJyYXJ5KHtcbiAgICAgIG5hbWUsXG4gICAgICB2YWx1ZTogcmVzXG4gICAgfSk7XG4gICAgcmV0dXJuIHJlcztcbiAgfSwgW2xvYWRlZExpYnJhcmllc10pO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIChhc3luYyAoKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBwYXJhbXMgPSBfZXh0ZW5kcyh7XG4gICAgICAgICAga2V5OiBhcGlLZXlcbiAgICAgICAgfSwgb3RoZXJBcGlQYXJhbXMpO1xuICAgICAgICBpZiAodmVyc2lvbikgcGFyYW1zLnYgPSB2ZXJzaW9uO1xuICAgICAgICBpZiAoKGxpYnJhcmllc1N0cmluZyA9PSBudWxsID8gdm9pZCAwIDogbGlicmFyaWVzU3RyaW5nLmxlbmd0aCkgPiAwKSBwYXJhbXMubGlicmFyaWVzID0gbGlicmFyaWVzU3RyaW5nO1xuICAgICAgICBhd2FpdCBHb29nbGVNYXBzQXBpTG9hZGVyLmxvYWQocGFyYW1zLCBzdGF0dXMgPT4gc2V0U3RhdHVzKHN0YXR1cykpO1xuICAgICAgICBmb3IgKGNvbnN0IG5hbWUgb2YgWydjb3JlJywgJ21hcHMnLCAuLi5saWJyYXJpZXNdKSB7XG4gICAgICAgICAgYXdhaXQgaW1wb3J0TGlicmFyeShuYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob25Mb2FkKSB7XG4gICAgICAgICAgb25Mb2FkKCk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJzxBcGlQcm92aWRlcj4gZmFpbGVkIHRvIGxvYWQgR29vZ2xlIE1hcHMgQVBJJywgZXJyb3IpO1xuICAgICAgfVxuICAgIH0pKCk7XG4gIH0sXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgW2FwaUtleSwgbGlicmFyaWVzU3RyaW5nLCBzZXJpYWxpemVkUGFyYW1zXSk7XG4gIHJldHVybiB7XG4gICAgc3RhdHVzLFxuICAgIGxvYWRlZExpYnJhcmllcyxcbiAgICBpbXBvcnRMaWJyYXJ5XG4gIH07XG59XG4vKipcbiAqIENvbXBvbmVudCB0byB3cmFwIHRoZSBHb29nbGUgTWFwcyBSZWFjdCBjb21wb25lbnRzIGFuZCBsb2FkIHRoZSBHb29nbGUgTWFwcyBKYXZhU2NyaXB0IEFQSVxuICovXG5jb25zdCBBUElQcm92aWRlciA9IHByb3BzID0+IHtcbiAgY29uc3Qge1xuICAgICAgY2hpbGRyZW5cbiAgICB9ID0gcHJvcHMsXG4gICAgbG9hZGVyUHJvcHMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShwcm9wcywgX2V4Y2x1ZGVkMik7XG4gIGNvbnN0IHtcbiAgICBtYXBJbnN0YW5jZXMsXG4gICAgYWRkTWFwSW5zdGFuY2UsXG4gICAgcmVtb3ZlTWFwSW5zdGFuY2UsXG4gICAgY2xlYXJNYXBJbnN0YW5jZXNcbiAgfSA9IHVzZU1hcEluc3RhbmNlcygpO1xuICBjb25zdCB7XG4gICAgc3RhdHVzLFxuICAgIGxvYWRlZExpYnJhcmllcyxcbiAgICBpbXBvcnRMaWJyYXJ5XG4gIH0gPSB1c2VHb29nbGVNYXBzQXBpTG9hZGVyKGxvYWRlclByb3BzKTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KEFQSVByb3ZpZGVyQ29udGV4dC5Qcm92aWRlciwge1xuICAgIHZhbHVlOiB7XG4gICAgICBtYXBJbnN0YW5jZXMsXG4gICAgICBhZGRNYXBJbnN0YW5jZSxcbiAgICAgIHJlbW92ZU1hcEluc3RhbmNlLFxuICAgICAgY2xlYXJNYXBJbnN0YW5jZXMsXG4gICAgICBzdGF0dXMsXG4gICAgICBsb2FkZWRMaWJyYXJpZXMsXG4gICAgICBpbXBvcnRMaWJyYXJ5XG4gICAgfVxuICB9LCBjaGlsZHJlbik7XG59O1xuXG4vKipcbiAqIFNldHMgdXAgZWZmZWN0cyB0byBiaW5kIGV2ZW50LWhhbmRsZXJzIGZvciBhbGwgZXZlbnQtcHJvcHMgaW4gTWFwRXZlbnRQcm9wcy5cbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiB1c2VNYXBFdmVudHMobWFwLCBwcm9wcykge1xuICAvLyBub3RlOiBjYWxsaW5nIGEgdXNlRWZmZWN0IGhvb2sgZnJvbSB3aXRoaW4gYSBsb29wIGlzIHByb2hpYml0ZWQgYnkgdGhlXG4gIC8vIHJ1bGVzIG9mIGhvb2tzLCBidXQgaXQncyBvayBoZXJlIHNpbmNlIGl0J3MgdW5jb25kaXRpb25hbCBhbmQgdGhlIG51bWJlclxuICAvLyBhbmQgb3JkZXIgb2YgaXRlcmF0aW9ucyBpcyBhbHdheXMgc3RyaWN0bHkgdGhlIHNhbWUuXG4gIC8vIChzZWUgaHR0cHM6Ly9sZWdhY3kucmVhY3Rqcy5vcmcvZG9jcy9ob29rcy1ydWxlcy5odG1sKVxuICBmb3IgKGNvbnN0IHByb3BOYW1lIG9mIGV2ZW50UHJvcE5hbWVzKSB7XG4gICAgLy8gZml4bWU6IHRoaXMgY2FzdCBpcyBlc3NlbnRpYWxseSBhICd0cnVzdCBtZSwgYnJvJyBmb3IgdHlwZXNjcmlwdCwgYnV0XG4gICAgLy8gICBhIHByb3BlciBzb2x1dGlvbiBzZWVtcyB3YXkgdG9vIGNvbXBsaWNhdGVkIHJpZ2h0IG5vd1xuICAgIGNvbnN0IGhhbmRsZXIgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgY29uc3QgZXZlbnRUeXBlID0gcHJvcE5hbWVUb0V2ZW50VHlwZVtwcm9wTmFtZV07XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL3J1bGVzLW9mLWhvb2tzXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgIGlmICghbWFwKSByZXR1cm47XG4gICAgICBpZiAoIWhhbmRsZXIpIHJldHVybjtcbiAgICAgIGNvbnN0IGxpc3RlbmVyID0gZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIobWFwLCBldmVudFR5cGUsIGV2ID0+IHtcbiAgICAgICAgaGFuZGxlcihjcmVhdGVNYXBFdmVudChldmVudFR5cGUsIG1hcCwgZXYpKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuICgpID0+IGxpc3RlbmVyLnJlbW92ZSgpO1xuICAgIH0sIFttYXAsIGV2ZW50VHlwZSwgaGFuZGxlcl0pO1xuICB9XG59XG4vKipcbiAqIENyZWF0ZSB0aGUgd3JhcHBlZCBtYXAtZXZlbnRzIHVzZWQgZm9yIHRoZSBldmVudC1wcm9wcy5cbiAqIEBwYXJhbSB0eXBlIHRoZSBldmVudCB0eXBlIGFzIGl0IGlzIHNwZWNpZmllZCB0byB0aGUgbWFwcyBhcGlcbiAqIEBwYXJhbSBtYXAgdGhlIG1hcCBpbnN0YW5jZSB0aGUgZXZlbnQgb3JpZ2luYXRlcyBmcm9tXG4gKiBAcGFyYW0gc3JjRXZlbnQgdGhlIHNvdXJjZS1ldmVudCBpZiB0aGVyZSBpcyBvbmUuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZU1hcEV2ZW50KHR5cGUsIG1hcCwgc3JjRXZlbnQpIHtcbiAgY29uc3QgZXYgPSB7XG4gICAgdHlwZSxcbiAgICBtYXAsXG4gICAgZGV0YWlsOiB7fSxcbiAgICBzdG9wcGFibGU6IGZhbHNlLFxuICAgIHN0b3A6ICgpID0+IHt9XG4gIH07XG4gIGlmIChjYW1lcmFFdmVudFR5cGVzLmluY2x1ZGVzKHR5cGUpKSB7XG4gICAgY29uc3QgY2FtRXZlbnQgPSBldjtcbiAgICBjb25zdCBjZW50ZXIgPSBtYXAuZ2V0Q2VudGVyKCk7XG4gICAgY29uc3Qgem9vbSA9IG1hcC5nZXRab29tKCk7XG4gICAgY29uc3QgaGVhZGluZyA9IG1hcC5nZXRIZWFkaW5nKCkgfHwgMDtcbiAgICBjb25zdCB0aWx0ID0gbWFwLmdldFRpbHQoKSB8fCAwO1xuICAgIGNvbnN0IGJvdW5kcyA9IG1hcC5nZXRCb3VuZHMoKTtcbiAgICBpZiAoIWNlbnRlciB8fCAhYm91bmRzIHx8ICFOdW1iZXIuaXNGaW5pdGUoem9vbSkpIHtcbiAgICAgIGNvbnNvbGUud2FybignW2NyZWF0ZUV2ZW50XSBhdCBsZWFzdCBvbmUgb2YgdGhlIHZhbHVlcyBmcm9tIHRoZSBtYXAgJyArICdyZXR1cm5lZCB1bmRlZmluZWQuIFRoaXMgaXMgbm90IGV4cGVjdGVkIHRvIGhhcHBlbi4gUGxlYXNlICcgKyAncmVwb3J0IGFuIGlzc3VlIGF0IGh0dHBzOi8vZ2l0aHViLmNvbS92aXNnbC9yZWFjdC1nb29nbGUtbWFwcy9pc3N1ZXMvbmV3Jyk7XG4gICAgfVxuICAgIGNhbUV2ZW50LmRldGFpbCA9IHtcbiAgICAgIGNlbnRlcjogKGNlbnRlciA9PSBudWxsID8gdm9pZCAwIDogY2VudGVyLnRvSlNPTigpKSB8fCB7XG4gICAgICAgIGxhdDogMCxcbiAgICAgICAgbG5nOiAwXG4gICAgICB9LFxuICAgICAgem9vbTogem9vbSB8fCAwLFxuICAgICAgaGVhZGluZzogaGVhZGluZyxcbiAgICAgIHRpbHQ6IHRpbHQsXG4gICAgICBib3VuZHM6IChib3VuZHMgPT0gbnVsbCA/IHZvaWQgMCA6IGJvdW5kcy50b0pTT04oKSkgfHwge1xuICAgICAgICBub3J0aDogOTAsXG4gICAgICAgIGVhc3Q6IDE4MCxcbiAgICAgICAgc291dGg6IC05MCxcbiAgICAgICAgd2VzdDogLTE4MFxuICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIGNhbUV2ZW50O1xuICB9IGVsc2UgaWYgKG1vdXNlRXZlbnRUeXBlcy5pbmNsdWRlcyh0eXBlKSkge1xuICAgIHZhciBfc3JjRXZlbnQkbGF0TG5nO1xuICAgIGlmICghc3JjRXZlbnQpIHRocm93IG5ldyBFcnJvcignW2NyZWF0ZUV2ZW50XSBtb3VzZSBldmVudHMgbXVzdCBwcm92aWRlIGEgc3JjRXZlbnQnKTtcbiAgICBjb25zdCBtb3VzZUV2ZW50ID0gZXY7XG4gICAgbW91c2VFdmVudC5kb21FdmVudCA9IHNyY0V2ZW50LmRvbUV2ZW50O1xuICAgIG1vdXNlRXZlbnQuc3RvcHBhYmxlID0gdHJ1ZTtcbiAgICBtb3VzZUV2ZW50LnN0b3AgPSAoKSA9PiBzcmNFdmVudC5zdG9wKCk7XG4gICAgbW91c2VFdmVudC5kZXRhaWwgPSB7XG4gICAgICBsYXRMbmc6ICgoX3NyY0V2ZW50JGxhdExuZyA9IHNyY0V2ZW50LmxhdExuZykgPT0gbnVsbCA/IHZvaWQgMCA6IF9zcmNFdmVudCRsYXRMbmcudG9KU09OKCkpIHx8IG51bGwsXG4gICAgICBwbGFjZUlkOiBzcmNFdmVudC5wbGFjZUlkXG4gICAgfTtcbiAgICByZXR1cm4gbW91c2VFdmVudDtcbiAgfVxuICByZXR1cm4gZXY7XG59XG4vKipcbiAqIG1hcHMgdGhlIGNhbWVsQ2FzZWQgbmFtZXMgb2YgZXZlbnQtcHJvcHMgdG8gdGhlIGNvcnJlc3BvbmRpbmcgZXZlbnQtdHlwZXNcbiAqIHVzZWQgaW4gdGhlIG1hcHMgQVBJLlxuICovXG5jb25zdCBwcm9wTmFtZVRvRXZlbnRUeXBlID0ge1xuICBvbkJvdW5kc0NoYW5nZWQ6ICdib3VuZHNfY2hhbmdlZCcsXG4gIG9uQ2VudGVyQ2hhbmdlZDogJ2NlbnRlcl9jaGFuZ2VkJyxcbiAgb25DbGljazogJ2NsaWNrJyxcbiAgb25Db250ZXh0bWVudTogJ2NvbnRleHRtZW51JyxcbiAgb25EYmxjbGljazogJ2RibGNsaWNrJyxcbiAgb25EcmFnOiAnZHJhZycsXG4gIG9uRHJhZ2VuZDogJ2RyYWdlbmQnLFxuICBvbkRyYWdzdGFydDogJ2RyYWdzdGFydCcsXG4gIG9uSGVhZGluZ0NoYW5nZWQ6ICdoZWFkaW5nX2NoYW5nZWQnLFxuICBvbklkbGU6ICdpZGxlJyxcbiAgb25Jc0ZyYWN0aW9uYWxab29tRW5hYmxlZENoYW5nZWQ6ICdpc2ZyYWN0aW9uYWx6b29tZW5hYmxlZF9jaGFuZ2VkJyxcbiAgb25NYXBDYXBhYmlsaXRpZXNDaGFuZ2VkOiAnbWFwY2FwYWJpbGl0aWVzX2NoYW5nZWQnLFxuICBvbk1hcFR5cGVJZENoYW5nZWQ6ICdtYXB0eXBlaWRfY2hhbmdlZCcsXG4gIG9uTW91c2Vtb3ZlOiAnbW91c2Vtb3ZlJyxcbiAgb25Nb3VzZW91dDogJ21vdXNlb3V0JyxcbiAgb25Nb3VzZW92ZXI6ICdtb3VzZW92ZXInLFxuICBvblByb2plY3Rpb25DaGFuZ2VkOiAncHJvamVjdGlvbl9jaGFuZ2VkJyxcbiAgb25SZW5kZXJpbmdUeXBlQ2hhbmdlZDogJ3JlbmRlcmluZ3R5cGVfY2hhbmdlZCcsXG4gIG9uVGlsZXNMb2FkZWQ6ICd0aWxlc2xvYWRlZCcsXG4gIG9uVGlsdENoYW5nZWQ6ICd0aWx0X2NoYW5nZWQnLFxuICBvblpvb21DaGFuZ2VkOiAnem9vbV9jaGFuZ2VkJyxcbiAgLy8gbm90ZTogb25DYW1lcmFDaGFuZ2VkIGlzIGFuIGFsaWFzIGZvciB0aGUgYm91bmRzX2NoYW5nZWQgZXZlbnQsXG4gIC8vIHNpbmNlIHRoYXQgaXMgZ29pbmcgdG8gYmUgZmlyZWQgaW4gZXZlcnkgc2l0dWF0aW9uIHdoZXJlIHRoZSBjYW1lcmEgaXNcbiAgLy8gdXBkYXRlZC5cbiAgb25DYW1lcmFDaGFuZ2VkOiAnYm91bmRzX2NoYW5nZWQnXG59O1xuY29uc3QgY2FtZXJhRXZlbnRUeXBlcyA9IFsnYm91bmRzX2NoYW5nZWQnLCAnY2VudGVyX2NoYW5nZWQnLCAnaGVhZGluZ19jaGFuZ2VkJywgJ3Byb2plY3Rpb25fY2hhbmdlZCcsICd0aWx0X2NoYW5nZWQnLCAnem9vbV9jaGFuZ2VkJ107XG5jb25zdCBtb3VzZUV2ZW50VHlwZXMgPSBbJ2NsaWNrJywgJ2NvbnRleHRtZW51JywgJ2RibGNsaWNrJywgJ21vdXNlbW92ZScsICdtb3VzZW91dCcsICdtb3VzZW92ZXInXTtcbmNvbnN0IGV2ZW50UHJvcE5hbWVzID0gT2JqZWN0LmtleXMocHJvcE5hbWVUb0V2ZW50VHlwZSk7XG5cbmZ1bmN0aW9uIHVzZURlZXBDb21wYXJlRWZmZWN0KGVmZmVjdCwgZGVwcykge1xuICBjb25zdCByZWYgPSB1c2VSZWYodW5kZWZpbmVkKTtcbiAgaWYgKCFyZWYuY3VycmVudCB8fCAhaXNEZWVwRXF1YWwoZGVwcywgcmVmLmN1cnJlbnQpKSB7XG4gICAgcmVmLmN1cnJlbnQgPSBkZXBzO1xuICB9XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgdXNlRWZmZWN0KGVmZmVjdCwgcmVmLmN1cnJlbnQpO1xufVxuXG5jb25zdCBtYXBPcHRpb25LZXlzID0gbmV3IFNldChbJ2JhY2tncm91bmRDb2xvcicsICdjbGlja2FibGVJY29ucycsICdjb250cm9sU2l6ZScsICdkaXNhYmxlRGVmYXVsdFVJJywgJ2Rpc2FibGVEb3VibGVDbGlja1pvb20nLCAnZHJhZ2dhYmxlJywgJ2RyYWdnYWJsZUN1cnNvcicsICdkcmFnZ2luZ0N1cnNvcicsICdmdWxsc2NyZWVuQ29udHJvbCcsICdmdWxsc2NyZWVuQ29udHJvbE9wdGlvbnMnLCAnZ2VzdHVyZUhhbmRsaW5nJywgJ2lzRnJhY3Rpb25hbFpvb21FbmFibGVkJywgJ2tleWJvYXJkU2hvcnRjdXRzJywgJ21hcFR5cGVDb250cm9sJywgJ21hcFR5cGVDb250cm9sT3B0aW9ucycsICdtYXBUeXBlSWQnLCAnbWF4Wm9vbScsICdtaW5ab29tJywgJ25vQ2xlYXInLCAncGFuQ29udHJvbCcsICdwYW5Db250cm9sT3B0aW9ucycsICdyZXN0cmljdGlvbicsICdyb3RhdGVDb250cm9sJywgJ3JvdGF0ZUNvbnRyb2xPcHRpb25zJywgJ3NjYWxlQ29udHJvbCcsICdzY2FsZUNvbnRyb2xPcHRpb25zJywgJ3Njcm9sbHdoZWVsJywgJ3N0cmVldFZpZXcnLCAnc3RyZWV0Vmlld0NvbnRyb2wnLCAnc3RyZWV0Vmlld0NvbnRyb2xPcHRpb25zJywgJ3N0eWxlcycsICd6b29tQ29udHJvbCcsICd6b29tQ29udHJvbE9wdGlvbnMnXSk7XG4vKipcbiAqIEludGVybmFsIGhvb2sgdG8gdXBkYXRlIHRoZSBtYXAtb3B0aW9ucyB3aGVuIHByb3BzIGFyZSBjaGFuZ2VkLlxuICpcbiAqIEBwYXJhbSBtYXAgdGhlIG1hcCBpbnN0YW5jZVxuICogQHBhcmFtIG1hcFByb3BzIHRoZSBwcm9wcyB0byB1cGRhdGUgdGhlIG1hcC1pbnN0YW5jZSB3aXRoXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gdXNlTWFwT3B0aW9ucyhtYXAsIG1hcFByb3BzKSB7XG4gIC8qIGVzbGludC1kaXNhYmxlIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwcyAtLVxuICAgKlxuICAgKiBUaGUgZm9sbG93aW5nIGVmZmVjdHMgYXJlbid0IHRyaWdnZXJlZCB3aGVuIHRoZSBtYXAgaXMgY2hhbmdlZC5cbiAgICogSW4gdGhhdCBjYXNlLCB0aGUgdmFsdWVzIHdpbGwgYmUgb3IgaGF2ZSBiZWVuIHBhc3NlZCB0byB0aGUgbWFwXG4gICAqIGNvbnN0cnVjdG9yIHZpYSBtYXBPcHRpb25zLlxuICAgKi9cbiAgY29uc3QgbWFwT3B0aW9ucyA9IHt9O1xuICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMobWFwUHJvcHMpO1xuICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzKSB7XG4gICAgaWYgKCFtYXBPcHRpb25LZXlzLmhhcyhrZXkpKSBjb250aW51ZTtcbiAgICBtYXBPcHRpb25zW2tleV0gPSBtYXBQcm9wc1trZXldO1xuICB9XG4gIC8vIHVwZGF0ZSB0aGUgbWFwIG9wdGlvbnMgd2hlbiBtYXBPcHRpb25zIGlzIGNoYW5nZWRcbiAgLy8gTm90ZTogZHVlIHRvIHRoZSBkZXN0cnVjdHVyaW5nIGFib3ZlLCBtYXBPcHRpb25zIHdpbGwgYmUgc2VlbiBhcyBjaGFuZ2VkXG4gIC8vICAgd2l0aCBldmVyeSByZS1yZW5kZXIsIHNvIHdlJ3JlIGFzc3VtaW5nIHRoZSBtYXBzLWFwaSB3aWxsIHByb3Blcmx5XG4gIC8vICAgZGVhbCB3aXRoIHVuY2hhbmdlZCBvcHRpb24tdmFsdWVzIHBhc3NlZCBpbnRvIHNldE9wdGlvbnMuXG4gIHVzZURlZXBDb21wYXJlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIW1hcCkgcmV0dXJuO1xuICAgIG1hcC5zZXRPcHRpb25zKG1hcE9wdGlvbnMpO1xuICB9LCBbbWFwT3B0aW9uc10pO1xuICAvKiBlc2xpbnQtZW5hYmxlIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwcyAqL1xufVxuXG5mdW5jdGlvbiB1c2VBcGlMb2FkaW5nU3RhdHVzKCkge1xuICB2YXIgX3VzZUNvbnRleHQ7XG4gIHJldHVybiAoKF91c2VDb250ZXh0ID0gdXNlQ29udGV4dChBUElQcm92aWRlckNvbnRleHQpKSA9PSBudWxsID8gdm9pZCAwIDogX3VzZUNvbnRleHQuc3RhdHVzKSB8fCBBUElMb2FkaW5nU3RhdHVzLk5PVF9MT0FERUQ7XG59XG5cbi8qKlxuICogSW50ZXJuYWwgaG9vayB0aGF0IHVwZGF0ZXMgdGhlIGNhbWVyYSB3aGVuIGRlY2suZ2wgdmlld1N0YXRlIGNoYW5nZXMuXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gdXNlRGVja0dMQ2FtZXJhVXBkYXRlKG1hcCwgcHJvcHMpIHtcbiAgY29uc3Qge1xuICAgIHZpZXdwb3J0LFxuICAgIHZpZXdTdGF0ZVxuICB9ID0gcHJvcHM7XG4gIGNvbnN0IGlzRGVja0dsQ29udHJvbGxlZCA9ICEhdmlld3BvcnQ7XG4gIHVzZUxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFtYXAgfHwgIXZpZXdTdGF0ZSkgcmV0dXJuO1xuICAgIGNvbnN0IHtcbiAgICAgIGxhdGl0dWRlLFxuICAgICAgbG9uZ2l0dWRlLFxuICAgICAgYmVhcmluZzogaGVhZGluZyxcbiAgICAgIHBpdGNoOiB0aWx0LFxuICAgICAgem9vbVxuICAgIH0gPSB2aWV3U3RhdGU7XG4gICAgbWFwLm1vdmVDYW1lcmEoe1xuICAgICAgY2VudGVyOiB7XG4gICAgICAgIGxhdDogbGF0aXR1ZGUsXG4gICAgICAgIGxuZzogbG9uZ2l0dWRlXG4gICAgICB9LFxuICAgICAgaGVhZGluZyxcbiAgICAgIHRpbHQsXG4gICAgICB6b29tOiB6b29tICsgMVxuICAgIH0pO1xuICB9LCBbbWFwLCB2aWV3U3RhdGVdKTtcbiAgcmV0dXJuIGlzRGVja0dsQ29udHJvbGxlZDtcbn1cblxuZnVuY3Rpb24gaXNMYXRMbmdMaXRlcmFsKG9iaikge1xuICBpZiAoIW9iaiB8fCB0eXBlb2Ygb2JqICE9PSAnb2JqZWN0JykgcmV0dXJuIGZhbHNlO1xuICBpZiAoISgnbGF0JyBpbiBvYmogJiYgJ2xuZycgaW4gb2JqKSkgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gTnVtYmVyLmlzRmluaXRlKG9iai5sYXQpICYmIE51bWJlci5pc0Zpbml0ZShvYmoubG5nKTtcbn1cbmZ1bmN0aW9uIGxhdExuZ0VxdWFscyhhLCBiKSB7XG4gIGlmICghYSB8fCAhYikgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBBID0gdG9MYXRMbmdMaXRlcmFsKGEpO1xuICBjb25zdCBCID0gdG9MYXRMbmdMaXRlcmFsKGIpO1xuICBpZiAoQS5sYXQgIT09IEIubGF0IHx8IEEubG5nICE9PSBCLmxuZykgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIHRvTGF0TG5nTGl0ZXJhbChvYmopIHtcbiAgaWYgKGlzTGF0TG5nTGl0ZXJhbChvYmopKSByZXR1cm4gb2JqO1xuICByZXR1cm4gb2JqLnRvSlNPTigpO1xufVxuXG5mdW5jdGlvbiB1c2VNYXBDYW1lcmFQYXJhbXMobWFwLCBjYW1lcmFTdGF0ZVJlZiwgbWFwUHJvcHMpIHtcbiAgY29uc3QgY2VudGVyID0gbWFwUHJvcHMuY2VudGVyID8gdG9MYXRMbmdMaXRlcmFsKG1hcFByb3BzLmNlbnRlcikgOiBudWxsO1xuICBsZXQgbGF0ID0gbnVsbDtcbiAgbGV0IGxuZyA9IG51bGw7XG4gIGlmIChjZW50ZXIgJiYgTnVtYmVyLmlzRmluaXRlKGNlbnRlci5sYXQpICYmIE51bWJlci5pc0Zpbml0ZShjZW50ZXIubG5nKSkge1xuICAgIGxhdCA9IGNlbnRlci5sYXQ7XG4gICAgbG5nID0gY2VudGVyLmxuZztcbiAgfVxuICBjb25zdCB6b29tID0gTnVtYmVyLmlzRmluaXRlKG1hcFByb3BzLnpvb20pID8gbWFwUHJvcHMuem9vbSA6IG51bGw7XG4gIGNvbnN0IGhlYWRpbmcgPSBOdW1iZXIuaXNGaW5pdGUobWFwUHJvcHMuaGVhZGluZykgPyBtYXBQcm9wcy5oZWFkaW5nIDogbnVsbDtcbiAgY29uc3QgdGlsdCA9IE51bWJlci5pc0Zpbml0ZShtYXBQcm9wcy50aWx0KSA/IG1hcFByb3BzLnRpbHQgOiBudWxsO1xuICAvLyB0aGUgZm9sbG93aW5nIGVmZmVjdCBydW5zIGZvciBldmVyeSByZW5kZXIgb2YgdGhlIG1hcCBjb21wb25lbnQgYW5kIGNoZWNrc1xuICAvLyBpZiB0aGVyZSBhcmUgZGlmZmVyZW5jZXMgYmV0d2VlbiB0aGUga25vd24gc3RhdGUgb2YgdGhlIG1hcCBpbnN0YW5jZVxuICAvLyAoY2FtZXJhU3RhdGVSZWYsIHdoaWNoIGlzIHVwZGF0ZWQgYnkgYWxsIGJvdW5kc19jaGFuZ2VkIGV2ZW50cykgYW5kIHRoZVxuICAvLyBkZXNpcmVkIHN0YXRlIGluIHRoZSBwcm9wcy5cbiAgdXNlTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIW1hcCkgcmV0dXJuO1xuICAgIGNvbnN0IG5leHRDYW1lcmEgPSB7fTtcbiAgICBsZXQgbmVlZHNVcGRhdGUgPSBmYWxzZTtcbiAgICBpZiAobGF0ICE9PSBudWxsICYmIGxuZyAhPT0gbnVsbCAmJiAoY2FtZXJhU3RhdGVSZWYuY3VycmVudC5jZW50ZXIubGF0ICE9PSBsYXQgfHwgY2FtZXJhU3RhdGVSZWYuY3VycmVudC5jZW50ZXIubG5nICE9PSBsbmcpKSB7XG4gICAgICBuZXh0Q2FtZXJhLmNlbnRlciA9IHtcbiAgICAgICAgbGF0LFxuICAgICAgICBsbmdcbiAgICAgIH07XG4gICAgICBuZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgfVxuICAgIGlmICh6b29tICE9PSBudWxsICYmIGNhbWVyYVN0YXRlUmVmLmN1cnJlbnQuem9vbSAhPT0gem9vbSkge1xuICAgICAgbmV4dENhbWVyYS56b29tID0gem9vbTtcbiAgICAgIG5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGhlYWRpbmcgIT09IG51bGwgJiYgY2FtZXJhU3RhdGVSZWYuY3VycmVudC5oZWFkaW5nICE9PSBoZWFkaW5nKSB7XG4gICAgICBuZXh0Q2FtZXJhLmhlYWRpbmcgPSBoZWFkaW5nO1xuICAgICAgbmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAodGlsdCAhPT0gbnVsbCAmJiBjYW1lcmFTdGF0ZVJlZi5jdXJyZW50LnRpbHQgIT09IHRpbHQpIHtcbiAgICAgIG5leHRDYW1lcmEudGlsdCA9IHRpbHQ7XG4gICAgICBuZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgfVxuICAgIGlmIChuZWVkc1VwZGF0ZSkge1xuICAgICAgbWFwLm1vdmVDYW1lcmEobmV4dENhbWVyYSk7XG4gICAgfVxuICB9KTtcbn1cblxuY29uc3QgQXV0aEZhaWx1cmVNZXNzYWdlID0gKCkgPT4ge1xuICBjb25zdCBzdHlsZSA9IHtcbiAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICB0b3A6IDAsXG4gICAgbGVmdDogMCxcbiAgICBib3R0b206IDAsXG4gICAgcmlnaHQ6IDAsXG4gICAgekluZGV4OiA5OTksXG4gICAgZGlzcGxheTogJ2ZsZXgnLFxuICAgIGZsZXhGbG93OiAnY29sdW1uIG5vd3JhcCcsXG4gICAgdGV4dEFsaWduOiAnY2VudGVyJyxcbiAgICBqdXN0aWZ5Q29udGVudDogJ2NlbnRlcicsXG4gICAgZm9udFNpemU6ICcuOHJlbScsXG4gICAgY29sb3I6ICdyZ2JhKDAsMCwwLDAuNiknLFxuICAgIGJhY2tncm91bmQ6ICcjZGRkZGRkJyxcbiAgICBwYWRkaW5nOiAnMXJlbSAxLjVyZW0nXG4gIH07XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgc3R5bGU6IHN0eWxlXG4gIH0sIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwiaDJcIiwgbnVsbCwgXCJFcnJvcjogQXV0aEZhaWx1cmVcIiksIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwicFwiLCBudWxsLCBcIkEgcHJvYmxlbSB3aXRoIHlvdXIgQVBJIGtleSBwcmV2ZW50cyB0aGUgbWFwIGZyb20gcmVuZGVyaW5nIGNvcnJlY3RseS4gUGxlYXNlIG1ha2Ugc3VyZSB0aGUgdmFsdWUgb2YgdGhlIFwiLCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImNvZGVcIiwgbnVsbCwgXCJBUElQcm92aWRlci5hcGlLZXlcIiksIFwiIHByb3AgaXMgY29ycmVjdC4gQ2hlY2sgdGhlIGVycm9yLW1lc3NhZ2UgaW4gdGhlIGNvbnNvbGUgZm9yIGZ1cnRoZXIgZGV0YWlscy5cIikpO1xufTtcblxuZnVuY3Rpb24gdXNlQ2FsbGJhY2tSZWYoKSB7XG4gIGNvbnN0IFtlbCwgc2V0RWxdID0gdXNlU3RhdGUobnVsbCk7XG4gIGNvbnN0IHJlZiA9IHVzZUNhbGxiYWNrKHZhbHVlID0+IHNldEVsKHZhbHVlKSwgW3NldEVsXSk7XG4gIHJldHVybiBbZWwsIHJlZl07XG59XG5cbi8qKlxuICogSG9vayB0byBjaGVjayBpZiB0aGUgR29vZ2xlIE1hcHMgQVBJIGlzIGxvYWRlZFxuICovXG5mdW5jdGlvbiB1c2VBcGlJc0xvYWRlZCgpIHtcbiAgY29uc3Qgc3RhdHVzID0gdXNlQXBpTG9hZGluZ1N0YXR1cygpO1xuICByZXR1cm4gc3RhdHVzID09PSBBUElMb2FkaW5nU3RhdHVzLkxPQURFRDtcbn1cblxuZnVuY3Rpb24gdXNlRm9yY2VVcGRhdGUoKSB7XG4gIGNvbnN0IFssIGZvcmNlVXBkYXRlXSA9IHVzZVJlZHVjZXIoeCA9PiB4ICsgMSwgMCk7XG4gIHJldHVybiBmb3JjZVVwZGF0ZTtcbn1cblxuZnVuY3Rpb24gaGFuZGxlQm91bmRzQ2hhbmdlKG1hcCwgcmVmKSB7XG4gIGNvbnN0IGNlbnRlciA9IG1hcC5nZXRDZW50ZXIoKTtcbiAgY29uc3Qgem9vbSA9IG1hcC5nZXRab29tKCk7XG4gIGNvbnN0IGhlYWRpbmcgPSBtYXAuZ2V0SGVhZGluZygpIHx8IDA7XG4gIGNvbnN0IHRpbHQgPSBtYXAuZ2V0VGlsdCgpIHx8IDA7XG4gIGNvbnN0IGJvdW5kcyA9IG1hcC5nZXRCb3VuZHMoKTtcbiAgaWYgKCFjZW50ZXIgfHwgIWJvdW5kcyB8fCAhTnVtYmVyLmlzRmluaXRlKHpvb20pKSB7XG4gICAgY29uc29sZS53YXJuKCdbdXNlVHJhY2tlZENhbWVyYVN0YXRlXSBhdCBsZWFzdCBvbmUgb2YgdGhlIHZhbHVlcyBmcm9tIHRoZSBtYXAgJyArICdyZXR1cm5lZCB1bmRlZmluZWQuIFRoaXMgaXMgbm90IGV4cGVjdGVkIHRvIGhhcHBlbi4gUGxlYXNlICcgKyAncmVwb3J0IGFuIGlzc3VlIGF0IGh0dHBzOi8vZ2l0aHViLmNvbS92aXNnbC9yZWFjdC1nb29nbGUtbWFwcy9pc3N1ZXMvbmV3Jyk7XG4gIH1cbiAgLy8gZml4bWU6IGRvIHdlIG5lZWQgdGhlIGB1bmRlZmluZWRgIGNhc2VzIGZvciB0aGUgY2FtZXJhLXBhcmFtcz8gV2hlbiBhcmUgdGhleSB1c2VkIGluIHRoZSBtYXBzIEFQST9cbiAgT2JqZWN0LmFzc2lnbihyZWYuY3VycmVudCwge1xuICAgIGNlbnRlcjogKGNlbnRlciA9PSBudWxsID8gdm9pZCAwIDogY2VudGVyLnRvSlNPTigpKSB8fCB7XG4gICAgICBsYXQ6IDAsXG4gICAgICBsbmc6IDBcbiAgICB9LFxuICAgIHpvb206IHpvb20gfHwgMCxcbiAgICBoZWFkaW5nOiBoZWFkaW5nLFxuICAgIHRpbHQ6IHRpbHRcbiAgfSk7XG59XG4vKipcbiAqIENyZWF0ZXMgYSBtdXRhYmxlIHJlZiBvYmplY3QgdG8gdHJhY2sgdGhlIGxhc3Qga25vd24gc3RhdGUgb2YgdGhlIG1hcCBjYW1lcmEuXG4gKiBUaGlzIGlzIHVzZWQgaW4gYHVzZU1hcENhbWVyYVBhcmFtc2AgdG8gcmVkdWNlIHN0dXR0ZXJpbmcgaW4gbm9ybWFsIG9wZXJhdGlvblxuICogYnkgYXZvaWRpbmcgdXBkYXRlcyBvZiB0aGUgbWFwIGNhbWVyYSB3aXRoIHZhbHVlcyB0aGF0IGhhdmUgYWxyZWFkeSBiZWVuIHByb2Nlc3NlZC5cbiAqL1xuZnVuY3Rpb24gdXNlVHJhY2tlZENhbWVyYVN0YXRlUmVmKG1hcCkge1xuICBjb25zdCBmb3JjZVVwZGF0ZSA9IHVzZUZvcmNlVXBkYXRlKCk7XG4gIGNvbnN0IHJlZiA9IHVzZVJlZih7XG4gICAgY2VudGVyOiB7XG4gICAgICBsYXQ6IDAsXG4gICAgICBsbmc6IDBcbiAgICB9LFxuICAgIGhlYWRpbmc6IDAsXG4gICAgdGlsdDogMCxcbiAgICB6b29tOiAwXG4gIH0pO1xuICAvLyBSZWNvcmQgY2FtZXJhIHN0YXRlIHdpdGggZXZlcnkgYm91bmRzX2NoYW5nZWQgZXZlbnQgZGlzcGF0Y2hlZCBieSB0aGUgbWFwLlxuICAvLyBUaGlzIGRhdGEgaXMgdXNlZCB0byBwcmV2ZW50IGZlZWRpbmcgdGhlc2UgdmFsdWVzIGJhY2sgdG8gdGhlXG4gIC8vIG1hcC1pbnN0YW5jZSB3aGVuIGEgdHlwaWNhbCBcImNvbnRyb2xsZWQgY29tcG9uZW50XCIgc2V0dXAgKHN0YXRlIHZhcmlhYmxlIGlzXG4gIC8vIGZlZCBpbnRvIGFuZCB1cGRhdGVkIGJ5IHRoZSBtYXApLlxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghbWFwKSByZXR1cm47XG4gICAgY29uc3QgbGlzdGVuZXIgPSBnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihtYXAsICdib3VuZHNfY2hhbmdlZCcsICgpID0+IHtcbiAgICAgIGhhbmRsZUJvdW5kc0NoYW5nZShtYXAsIHJlZik7XG4gICAgICAvLyBXaGVuIGFuIGV2ZW50IGlzIG9jY3VyZWQsIHdlIGhhdmUgdG8gdXBkYXRlIGR1cmluZyB0aGUgbmV4dCBjeWNsZS5cbiAgICAgIC8vIFRoZSBhcHBsaWNhdGlvbiBjb3VsZCBkZWNpZGUgdG8gaWdub3JlIHRoZSBldmVudCBhbmQgbm90IHVwZGF0ZSBhbnlcbiAgICAgIC8vIGNhbWVyYSBwcm9wcyBvZiB0aGUgbWFwLCBtZWFuaW5nIHRoYXQgaW4gdGhhdCBjYXNlIHdlIHdpbGwgaGF2ZSB0b1xuICAgICAgLy8gJ3VuZG8nIHRoZSBjaGFuZ2UgdG8gdGhlIGNhbWVyYS5cbiAgICAgIGZvcmNlVXBkYXRlKCk7XG4gICAgfSk7XG4gICAgcmV0dXJuICgpID0+IGxpc3RlbmVyLnJlbW92ZSgpO1xuICB9LCBbbWFwLCBmb3JjZVVwZGF0ZV0pO1xuICByZXR1cm4gcmVmO1xufVxuXG5jb25zdCBfZXhjbHVkZWQkMiA9IFtcImlkXCIsIFwiZGVmYXVsdEJvdW5kc1wiLCBcImRlZmF1bHRDZW50ZXJcIiwgXCJkZWZhdWx0Wm9vbVwiLCBcImRlZmF1bHRIZWFkaW5nXCIsIFwiZGVmYXVsdFRpbHRcIl07XG4vKipcbiAqIFRoZSBtYWluIGhvb2sgdGFrZXMgY2FyZSBvZiBjcmVhdGluZyBtYXAtaW5zdGFuY2VzIGFuZCByZWdpc3RlcmluZyB0aGVtIGluXG4gKiB0aGUgYXBpLXByb3ZpZGVyIGNvbnRleHQuXG4gKiBAcmV0dXJuIGEgdHVwbGUgb2YgdGhlIG1hcC1pbnN0YW5jZSBjcmVhdGVkIChvciBudWxsKSBhbmQgdGhlIGNhbGxiYWNrXG4gKiAgIHJlZiB0aGF0IHdpbGwgYmUgdXNlZCB0byBwYXNzIHRoZSBtYXAtY29udGFpbmVyIGludG8gdGhpcyBob29rLlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIHVzZU1hcEluc3RhbmNlKHByb3BzLCBjb250ZXh0KSB7XG4gIGNvbnN0IGFwaUlzTG9hZGVkID0gdXNlQXBpSXNMb2FkZWQoKTtcbiAgY29uc3QgW21hcCwgc2V0TWFwXSA9IHVzZVN0YXRlKG51bGwpO1xuICBjb25zdCBbY29udGFpbmVyLCBjb250YWluZXJSZWZdID0gdXNlQ2FsbGJhY2tSZWYoKTtcbiAgY29uc3QgY2FtZXJhU3RhdGVSZWYgPSB1c2VUcmFja2VkQ2FtZXJhU3RhdGVSZWYobWFwKTtcbiAgY29uc3Qge1xuICAgICAgaWQsXG4gICAgICBkZWZhdWx0Qm91bmRzLFxuICAgICAgZGVmYXVsdENlbnRlcixcbiAgICAgIGRlZmF1bHRab29tLFxuICAgICAgZGVmYXVsdEhlYWRpbmcsXG4gICAgICBkZWZhdWx0VGlsdFxuICAgIH0gPSBwcm9wcyxcbiAgICBtYXBPcHRpb25zID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UocHJvcHMsIF9leGNsdWRlZCQyKTtcbiAgLy8gYXBwbHkgZGVmYXVsdCBjYW1lcmEgcHJvcHMgaWYgYXZhaWxhYmxlIGFuZCBub3Qgb3ZlcndyaXR0ZW4gYnkgY29udHJvbGxlZCBwcm9wc1xuICBpZiAoIW1hcE9wdGlvbnMuY2VudGVyICYmIGRlZmF1bHRDZW50ZXIpIG1hcE9wdGlvbnMuY2VudGVyID0gZGVmYXVsdENlbnRlcjtcbiAgaWYgKCFtYXBPcHRpb25zLnpvb20gJiYgTnVtYmVyLmlzRmluaXRlKGRlZmF1bHRab29tKSkgbWFwT3B0aW9ucy56b29tID0gZGVmYXVsdFpvb207XG4gIGlmICghbWFwT3B0aW9ucy5oZWFkaW5nICYmIE51bWJlci5pc0Zpbml0ZShkZWZhdWx0SGVhZGluZykpIG1hcE9wdGlvbnMuaGVhZGluZyA9IGRlZmF1bHRIZWFkaW5nO1xuICBpZiAoIW1hcE9wdGlvbnMudGlsdCAmJiBOdW1iZXIuaXNGaW5pdGUoZGVmYXVsdFRpbHQpKSBtYXBPcHRpb25zLnRpbHQgPSBkZWZhdWx0VGlsdDtcbiAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMobWFwT3B0aW9ucykpIGlmIChtYXBPcHRpb25zW2tleV0gPT09IHVuZGVmaW5lZCkgZGVsZXRlIG1hcE9wdGlvbnNba2V5XTtcbiAgY29uc3Qgc2F2ZWRNYXBTdGF0ZVJlZiA9IHVzZVJlZigpO1xuICAvLyBjcmVhdGUgdGhlIG1hcCBpbnN0YW5jZSBhbmQgcmVnaXN0ZXIgaXQgaW4gdGhlIGNvbnRleHRcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIWNvbnRhaW5lciB8fCAhYXBpSXNMb2FkZWQpIHJldHVybjtcbiAgICBjb25zdCB7XG4gICAgICBhZGRNYXBJbnN0YW5jZSxcbiAgICAgIHJlbW92ZU1hcEluc3RhbmNlXG4gICAgfSA9IGNvbnRleHQ7XG4gICAgY29uc3QgbWFwSWQgPSBwcm9wcy5tYXBJZDtcbiAgICBjb25zdCBuZXdNYXAgPSBuZXcgZ29vZ2xlLm1hcHMuTWFwKGNvbnRhaW5lciwgbWFwT3B0aW9ucyk7XG4gICAgc2V0TWFwKG5ld01hcCk7XG4gICAgYWRkTWFwSW5zdGFuY2UobmV3TWFwLCBpZCk7XG4gICAgaWYgKGRlZmF1bHRCb3VuZHMpIHtcbiAgICAgIG5ld01hcC5maXRCb3VuZHMoZGVmYXVsdEJvdW5kcyk7XG4gICAgfVxuICAgIC8vIHRoZSBzYXZlZE1hcFN0YXRlIGlzIHVzZWQgdG8gcmVzdG9yZSB0aGUgY2FtZXJhIHBhcmFtZXRlcnMgd2hlbiB0aGUgbWFwSWQgaXMgY2hhbmdlZFxuICAgIGlmIChzYXZlZE1hcFN0YXRlUmVmLmN1cnJlbnQpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgbWFwSWQ6IHNhdmVkTWFwSWQsXG4gICAgICAgIGNhbWVyYVN0YXRlOiBzYXZlZENhbWVyYVN0YXRlXG4gICAgICB9ID0gc2F2ZWRNYXBTdGF0ZVJlZi5jdXJyZW50O1xuICAgICAgaWYgKHNhdmVkTWFwSWQgIT09IG1hcElkKSB7XG4gICAgICAgIG5ld01hcC5zZXRPcHRpb25zKHNhdmVkQ2FtZXJhU3RhdGUpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgc2F2ZWRNYXBTdGF0ZVJlZi5jdXJyZW50ID0ge1xuICAgICAgICBtYXBJZCxcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICAgICAgICBjYW1lcmFTdGF0ZTogY2FtZXJhU3RhdGVSZWYuY3VycmVudFxuICAgICAgfTtcbiAgICAgIC8vIHJlbW92ZSBhbGwgZXZlbnQtbGlzdGVuZXJzIHRvIG1pbmltaXplIG1lbW9yeS1sZWFrc1xuICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQuY2xlYXJJbnN0YW5jZUxpc3RlbmVycyhuZXdNYXApO1xuICAgICAgc2V0TWFwKG51bGwpO1xuICAgICAgcmVtb3ZlTWFwSW5zdGFuY2UoaWQpO1xuICAgIH07XG4gIH0sXG4gIC8vIHNvbWUgZGVwZW5kZW5jaWVzIGFyZSBpZ25vcmVkIGluIHRoZSBsaXN0IGJlbG93OlxuICAvLyAgLSBkZWZhdWx0Qm91bmRzIGFuZCB0aGUgZGVmYXVsdCogY2FtZXJhIHByb3BzIHdpbGwgb25seSBiZSB1c2VkIG9uY2UsIGFuZFxuICAvLyAgICBjaGFuZ2VzIHNob3VsZCBiZSBpZ25vcmVkXG4gIC8vICAtIG1hcE9wdGlvbnMgaGFzIHNwZWNpYWwgaG9va3MgdGhhdCB0YWtlIGNhcmUgb2YgdXBkYXRpbmcgdGhlIG9wdGlvbnNcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICBbY29udGFpbmVyLCBhcGlJc0xvYWRlZCwgaWQsIHByb3BzLm1hcElkXSk7XG4gIHJldHVybiBbbWFwLCBjb250YWluZXJSZWYsIGNhbWVyYVN0YXRlUmVmXTtcbn1cblxuY29uc3QgR29vZ2xlTWFwc0NvbnRleHQgPSBSZWFjdC5jcmVhdGVDb250ZXh0KG51bGwpO1xuY29uc3QgTWFwID0gcHJvcHMgPT4ge1xuICBjb25zdCB7XG4gICAgY2hpbGRyZW4sXG4gICAgaWQsXG4gICAgY2xhc3NOYW1lLFxuICAgIHN0eWxlXG4gIH0gPSBwcm9wcztcbiAgY29uc3QgY29udGV4dCA9IHVzZUNvbnRleHQoQVBJUHJvdmlkZXJDb250ZXh0KTtcbiAgY29uc3QgbG9hZGluZ1N0YXR1cyA9IHVzZUFwaUxvYWRpbmdTdGF0dXMoKTtcbiAgaWYgKCFjb250ZXh0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCc8TWFwPiBjYW4gb25seSBiZSB1c2VkIGluc2lkZSBhbiA8QXBpUHJvdmlkZXI+IGNvbXBvbmVudC4nKTtcbiAgfVxuICBjb25zdCBbbWFwLCBtYXBSZWYsIGNhbWVyYVN0YXRlUmVmXSA9IHVzZU1hcEluc3RhbmNlKHByb3BzLCBjb250ZXh0KTtcbiAgdXNlTWFwQ2FtZXJhUGFyYW1zKG1hcCwgY2FtZXJhU3RhdGVSZWYsIHByb3BzKTtcbiAgdXNlTWFwRXZlbnRzKG1hcCwgcHJvcHMpO1xuICB1c2VNYXBPcHRpb25zKG1hcCwgcHJvcHMpO1xuICBjb25zdCBpc0RlY2tHbENvbnRyb2xsZWQgPSB1c2VEZWNrR0xDYW1lcmFVcGRhdGUobWFwLCBwcm9wcyk7XG4gIGNvbnN0IGlzQ29udHJvbGxlZEV4dGVybmFsbHkgPSAhIXByb3BzLmNvbnRyb2xsZWQ7XG4gIC8vIGRpc2FibGUgaW50ZXJhY3Rpb25zIHdpdGggdGhlIG1hcCBmb3IgZXh0ZXJuYWxseSBjb250cm9sbGVkIG1hcHNcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIW1hcCkgcmV0dXJuO1xuICAgIC8vIGZpeG1lOiB0aGlzIGRvZXNuJ3Qgc2VlbSB0byBiZWxvbmcgaGVyZSAoYW5kIGl0J3MgbW9zdGx5IHRoZXJlIGZvciBjb252ZW5pZW5jZSBhbnl3YXkpLlxuICAgIC8vICAgVGhlIHJlYXNvbmluZyBpcyB0aGF0IGEgZGVjay5nbCBjYW52YXMgd2lsbCBiZSBwdXQgb24gdG9wIG9mIHRoZSBtYXAsIHJlbmRlcmluZ1xuICAgIC8vICAgYW55IGRlZmF1bHQgbWFwIGNvbnRyb2xzIHByZXR0eSBtdWNoIHVzZWxlc3NcbiAgICBpZiAoaXNEZWNrR2xDb250cm9sbGVkKSB7XG4gICAgICBtYXAuc2V0T3B0aW9ucyh7XG4gICAgICAgIGRpc2FibGVEZWZhdWx0VUk6IHRydWVcbiAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBkaXNhYmxlIGFsbCBjb250cm9sLWlucHV0cyB3aGVuIHRoZSBtYXAgaXMgY29udHJvbGxlZCBleHRlcm5hbGx5XG4gICAgaWYgKGlzRGVja0dsQ29udHJvbGxlZCB8fCBpc0NvbnRyb2xsZWRFeHRlcm5hbGx5KSB7XG4gICAgICBtYXAuc2V0T3B0aW9ucyh7XG4gICAgICAgIGdlc3R1cmVIYW5kbGluZzogJ25vbmUnLFxuICAgICAgICBrZXlib2FyZFNob3J0Y3V0czogZmFsc2VcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgbWFwLnNldE9wdGlvbnMoe1xuICAgICAgICBnZXN0dXJlSGFuZGxpbmc6IHByb3BzLmdlc3R1cmVIYW5kbGluZyxcbiAgICAgICAga2V5Ym9hcmRTaG9ydGN1dHM6IHByb3BzLmtleWJvYXJkU2hvcnRjdXRzXG4gICAgICB9KTtcbiAgICB9O1xuICB9LCBbbWFwLCBpc0RlY2tHbENvbnRyb2xsZWQsIGlzQ29udHJvbGxlZEV4dGVybmFsbHksIHByb3BzLmdlc3R1cmVIYW5kbGluZywgcHJvcHMua2V5Ym9hcmRTaG9ydGN1dHNdKTtcbiAgLy8gc2V0dXAgYSBzdGFibGUgY2FtZXJhT3B0aW9ucyBvYmplY3QgdGhhdCBjYW4gYmUgdXNlZCBhcyBkZXBlbmRlbmN5XG4gIGNvbnN0IGNlbnRlciA9IHByb3BzLmNlbnRlciA/IHRvTGF0TG5nTGl0ZXJhbChwcm9wcy5jZW50ZXIpIDogbnVsbDtcbiAgbGV0IGxhdCA9IG51bGw7XG4gIGxldCBsbmcgPSBudWxsO1xuICBpZiAoY2VudGVyICYmIE51bWJlci5pc0Zpbml0ZShjZW50ZXIubGF0KSAmJiBOdW1iZXIuaXNGaW5pdGUoY2VudGVyLmxuZykpIHtcbiAgICBsYXQgPSBjZW50ZXIubGF0O1xuICAgIGxuZyA9IGNlbnRlci5sbmc7XG4gIH1cbiAgY29uc3QgY2FtZXJhT3B0aW9ucyA9IHVzZU1lbW8oKCkgPT4ge1xuICAgIHZhciBfbGF0LCBfbG5nLCBfcHJvcHMkem9vbSwgX3Byb3BzJGhlYWRpbmcsIF9wcm9wcyR0aWx0O1xuICAgIHJldHVybiB7XG4gICAgICBjZW50ZXI6IHtcbiAgICAgICAgbGF0OiAoX2xhdCA9IGxhdCkgIT0gbnVsbCA/IF9sYXQgOiAwLFxuICAgICAgICBsbmc6IChfbG5nID0gbG5nKSAhPSBudWxsID8gX2xuZyA6IDBcbiAgICAgIH0sXG4gICAgICB6b29tOiAoX3Byb3BzJHpvb20gPSBwcm9wcy56b29tKSAhPSBudWxsID8gX3Byb3BzJHpvb20gOiAwLFxuICAgICAgaGVhZGluZzogKF9wcm9wcyRoZWFkaW5nID0gcHJvcHMuaGVhZGluZykgIT0gbnVsbCA/IF9wcm9wcyRoZWFkaW5nIDogMCxcbiAgICAgIHRpbHQ6IChfcHJvcHMkdGlsdCA9IHByb3BzLnRpbHQpICE9IG51bGwgPyBfcHJvcHMkdGlsdCA6IDBcbiAgICB9O1xuICB9LCBbbGF0LCBsbmcsIHByb3BzLnpvb20sIHByb3BzLmhlYWRpbmcsIHByb3BzLnRpbHRdKTtcbiAgLy8gZXh0ZXJuYWxseSBjb250cm9sbGVkIG1vZGU6IHJlamVjdCBhbGwgY2FtZXJhIGNoYW5nZXMgdGhhdCBkb24ndCBjb3JyZXNwb25kIHRvIGNoYW5nZXMgaW4gcHJvcHNcbiAgdXNlTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIW1hcCB8fCAhaXNDb250cm9sbGVkRXh0ZXJuYWxseSkgcmV0dXJuO1xuICAgIG1hcC5tb3ZlQ2FtZXJhKGNhbWVyYU9wdGlvbnMpO1xuICAgIGNvbnN0IGxpc3RlbmVyID0gbWFwLmFkZExpc3RlbmVyKCdib3VuZHNfY2hhbmdlZCcsICgpID0+IHtcbiAgICAgIG1hcC5tb3ZlQ2FtZXJhKGNhbWVyYU9wdGlvbnMpO1xuICAgIH0pO1xuICAgIHJldHVybiAoKSA9PiBsaXN0ZW5lci5yZW1vdmUoKTtcbiAgfSwgW21hcCwgaXNDb250cm9sbGVkRXh0ZXJuYWxseSwgY2FtZXJhT3B0aW9uc10pO1xuICBjb25zdCBjb21iaW5lZFN0eWxlID0gdXNlTWVtbygoKSA9PiBfZXh0ZW5kcyh7XG4gICAgd2lkdGg6ICcxMDAlJyxcbiAgICBoZWlnaHQ6ICcxMDAlJyxcbiAgICAvLyB3aGVuIHVzaW5nIGRlY2tnbCwgdGhlIG1hcCBzaG91bGQgYmUgc2VudCB0byB0aGUgYmFja1xuICAgIHpJbmRleDogaXNEZWNrR2xDb250cm9sbGVkID8gLTEgOiAwXG4gIH0sIHN0eWxlKSwgW3N0eWxlLCBpc0RlY2tHbENvbnRyb2xsZWRdKTtcbiAgaWYgKGxvYWRpbmdTdGF0dXMgPT09IEFQSUxvYWRpbmdTdGF0dXMuQVVUSF9GQUlMVVJFKSB7XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICAgIHN0eWxlOiBfZXh0ZW5kcyh7XG4gICAgICAgIHBvc2l0aW9uOiAncmVsYXRpdmUnXG4gICAgICB9LCBjbGFzc05hbWUgPyB7fSA6IGNvbWJpbmVkU3R5bGUpLFxuICAgICAgY2xhc3NOYW1lOiBjbGFzc05hbWVcbiAgICB9LCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChBdXRoRmFpbHVyZU1lc3NhZ2UsIG51bGwpKTtcbiAgfVxuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgX2V4dGVuZHMoe1xuICAgIHJlZjogbWFwUmVmLFxuICAgIFwiZGF0YS10ZXN0aWRcIjogJ21hcCcsXG4gICAgc3R5bGU6IGNsYXNzTmFtZSA/IHVuZGVmaW5lZCA6IGNvbWJpbmVkU3R5bGUsXG4gICAgY2xhc3NOYW1lOiBjbGFzc05hbWVcbiAgfSwgaWQgPyB7XG4gICAgaWRcbiAgfSA6IHt9KSwgbWFwID8gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoR29vZ2xlTWFwc0NvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZToge1xuICAgICAgbWFwXG4gICAgfVxuICB9LCBjaGlsZHJlbikgOiBudWxsKTtcbn07XG5NYXAuZGVja0dMVmlld1Byb3BzID0gdHJ1ZTtcblxuZnVuY3Rpb24gdXNlTWFwc0xpYnJhcnkobmFtZSkge1xuICBjb25zdCBhcGlJc0xvYWRlZCA9IHVzZUFwaUlzTG9hZGVkKCk7XG4gIGNvbnN0IGN0eCA9IHVzZUNvbnRleHQoQVBJUHJvdmlkZXJDb250ZXh0KTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIWFwaUlzTG9hZGVkIHx8ICFjdHgpIHJldHVybjtcbiAgICAvLyBUcmlnZ2VyIGxvYWRpbmcgdGhlIGxpYnJhcmllcyB2aWEgb3VyIHByb3h5LW1ldGhvZC5cbiAgICAvLyBUaGUgcmV0dXJuZWQgcHJvbWlzZSBpcyBpZ25vcmVkLCBzaW5jZSBpbXBvcnRMaWJyYXJ5IHdpbGwgdXBkYXRlIGxvYWRlZExpYnJhcmllc1xuICAgIC8vIGxpc3QgaW4gdGhlIGNvbnRleHQsIHRyaWdnZXJpbmcgYSByZS1yZW5kZXIuXG4gICAgdm9pZCBjdHguaW1wb3J0TGlicmFyeShuYW1lKTtcbiAgfSwgW2FwaUlzTG9hZGVkLCBjdHgsIG5hbWVdKTtcbiAgcmV0dXJuIChjdHggPT0gbnVsbCA/IHZvaWQgMCA6IGN0eC5sb2FkZWRMaWJyYXJpZXNbbmFtZV0pIHx8IG51bGw7XG59XG5cbi8qIGVzbGludC1kaXNhYmxlIGNvbXBsZXhpdHkgKi9cbmNvbnN0IEFkdmFuY2VkTWFya2VyQ29udGV4dCA9IFJlYWN0LmNyZWF0ZUNvbnRleHQobnVsbCk7XG5mdW5jdGlvbiB1c2VBZHZhbmNlZE1hcmtlcihwcm9wcykge1xuICB2YXIgX3VzZUNvbnRleHQ7XG4gIGNvbnN0IFttYXJrZXIsIHNldE1hcmtlcl0gPSB1c2VTdGF0ZShudWxsKTtcbiAgY29uc3QgW2NvbnRlbnRDb250YWluZXIsIHNldENvbnRlbnRDb250YWluZXJdID0gdXNlU3RhdGUobnVsbCk7XG4gIGNvbnN0IG1hcCA9IChfdXNlQ29udGV4dCA9IHVzZUNvbnRleHQoR29vZ2xlTWFwc0NvbnRleHQpKSA9PSBudWxsID8gdm9pZCAwIDogX3VzZUNvbnRleHQubWFwO1xuICBjb25zdCBtYXJrZXJMaWJyYXJ5ID0gdXNlTWFwc0xpYnJhcnkoJ21hcmtlcicpO1xuICBjb25zdCB7XG4gICAgY2hpbGRyZW4sXG4gICAgY2xhc3NOYW1lLFxuICAgIG9uQ2xpY2ssXG4gICAgb25EcmFnLFxuICAgIG9uRHJhZ1N0YXJ0LFxuICAgIG9uRHJhZ0VuZCxcbiAgICBjb2xsaXNpb25CZWhhdmlvcixcbiAgICBkcmFnZ2FibGUsXG4gICAgcG9zaXRpb24sXG4gICAgdGl0bGUsXG4gICAgekluZGV4XG4gIH0gPSBwcm9wcztcbiAgY29uc3QgbnVtQ2hpbGRzID0gQ2hpbGRyZW4uY291bnQoY2hpbGRyZW4pO1xuICAvLyBjcmVhdGUgbWFya2VyIGluc3RhbmNlIGFuZCBhZGQgaXQgdG8gdGhlIG1hcCB3aGVuIG1hcCBiZWNvbWVzIGF2YWlsYWJsZVxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghbWFwIHx8ICFtYXJrZXJMaWJyYXJ5KSByZXR1cm47XG4gICAgY29uc3QgbmV3TWFya2VyID0gbmV3IG1hcmtlckxpYnJhcnkuQWR2YW5jZWRNYXJrZXJFbGVtZW50KCk7XG4gICAgbmV3TWFya2VyLm1hcCA9IG1hcDtcbiAgICBzZXRNYXJrZXIobmV3TWFya2VyKTtcbiAgICAvLyBjcmVhdGUgY29udGFpbmVyIGZvciBtYXJrZXIgY29udGVudCBpZiB0aGVyZSBhcmUgY2hpbGRyZW5cbiAgICBpZiAobnVtQ2hpbGRzID4gMCkge1xuICAgICAgY29uc3QgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIGlmIChjbGFzc05hbWUpIGVsLmNsYXNzTmFtZSA9IGNsYXNzTmFtZTtcbiAgICAgIG5ld01hcmtlci5jb250ZW50ID0gZWw7XG4gICAgICBzZXRDb250ZW50Q29udGFpbmVyKGVsKTtcbiAgICB9XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIG5ld01hcmtlci5tYXAgPSBudWxsO1xuICAgICAgc2V0TWFya2VyKG51bGwpO1xuICAgICAgc2V0Q29udGVudENvbnRhaW5lcihudWxsKTtcbiAgICB9O1xuICAgIC8vIFdlIGRvIG5vdCB3YW50IHRvIHJlLXJlbmRlciB0aGUgd2hvbGUgbWFya2VyIHdoZW4gdGhlIGNsYXNzTmFtZSBjaGFuZ2VzXG4gICAgLy8gYmVjYXVzZSB0aGF0IGNhdXNlcyBhIHNob3J0IGZsaWNrZXJpbmcgb2YgdGhlIG1hcmtlci5cbiAgICAvLyBUaGUgY2xhc3NOYW1lIHVwZGF0ZSBpcyBoYW5kbGVkIGluIHRoZSB1c2VFZmZlY3QgYmVsb3cuXG4gICAgLy8gRXhjbHVkaW5nIHRoZSBjbGFzc05hbWUgZnJvbSB0aGUgZGVwZW5kZW5jeSBhcnJheSBvbm0gcHVycG9zZSBoZXJlXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICB9LCBbbWFwLCBtYXJrZXJMaWJyYXJ5LCBudW1DaGlsZHNdKTtcbiAgLy8gdXBkYXRlIGNsYXNzTmFtZSBvZiBhZHZhbmNlZCBtYXJrZXIgZWxlbWVudFxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghY29udGVudENvbnRhaW5lcikgcmV0dXJuO1xuICAgIGNvbnRlbnRDb250YWluZXIuY2xhc3NOYW1lID0gY2xhc3NOYW1lICE9IG51bGwgPyBjbGFzc05hbWUgOiAnJztcbiAgfSwgW2NvbnRlbnRDb250YWluZXIsIGNsYXNzTmFtZV0pO1xuICAvLyBiaW5kIGFsbCBtYXJrZXIgZXZlbnRzXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFtYXJrZXIpIHJldHVybjtcbiAgICBjb25zdCBnbWUgPSBnb29nbGUubWFwcy5ldmVudDtcbiAgICBpZiAob25DbGljaykgZ21lLmFkZExpc3RlbmVyKG1hcmtlciwgJ2NsaWNrJywgb25DbGljayk7XG4gICAgaWYgKG9uRHJhZykgZ21lLmFkZExpc3RlbmVyKG1hcmtlciwgJ2RyYWcnLCBvbkRyYWcpO1xuICAgIGlmIChvbkRyYWdTdGFydCkgZ21lLmFkZExpc3RlbmVyKG1hcmtlciwgJ2RyYWdzdGFydCcsIG9uRHJhZ1N0YXJ0KTtcbiAgICBpZiAob25EcmFnRW5kKSBnbWUuYWRkTGlzdGVuZXIobWFya2VyLCAnZHJhZ2VuZCcsIG9uRHJhZ0VuZCk7XG4gICAgaWYgKChvbkRyYWcgfHwgb25EcmFnU3RhcnQgfHwgb25EcmFnRW5kKSAmJiAhZHJhZ2dhYmxlKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ1lvdSBuZWVkIHRvIHNldCB0aGUgbWFya2VyIHRvIGRyYWdnYWJsZSB0byBsaXN0ZW4gdG8gZHJhZy1ldmVudHMuJyk7XG4gICAgfVxuICAgIGNvbnN0IG0gPSBtYXJrZXI7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGdtZS5jbGVhckluc3RhbmNlTGlzdGVuZXJzKG0pO1xuICAgIH07XG4gIH0sIFttYXJrZXIsIGRyYWdnYWJsZSwgb25DbGljaywgb25EcmFnU3RhcnQsIG9uRHJhZywgb25EcmFnRW5kXSk7XG4gIC8vIHVwZGF0ZSBvdGhlciBtYXJrZXIgcHJvcHMgd2hlbiBjaGFuZ2VkXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFtYXJrZXIpIHJldHVybjtcbiAgICBpZiAocG9zaXRpb24gIT09IHVuZGVmaW5lZCkgbWFya2VyLnBvc2l0aW9uID0gcG9zaXRpb247XG4gICAgaWYgKGRyYWdnYWJsZSAhPT0gdW5kZWZpbmVkKSBtYXJrZXIuZ21wRHJhZ2dhYmxlID0gZHJhZ2dhYmxlO1xuICAgIGlmIChjb2xsaXNpb25CZWhhdmlvciAhPT0gdW5kZWZpbmVkKSBtYXJrZXIuY29sbGlzaW9uQmVoYXZpb3IgPSBjb2xsaXNpb25CZWhhdmlvcjtcbiAgICBpZiAoekluZGV4ICE9PSB1bmRlZmluZWQpIG1hcmtlci56SW5kZXggPSB6SW5kZXg7XG4gICAgaWYgKHR5cGVvZiB0aXRsZSA9PT0gJ3N0cmluZycpIG1hcmtlci50aXRsZSA9IHRpdGxlO1xuICB9LCBbbWFya2VyLCBwb3NpdGlvbiwgZHJhZ2dhYmxlLCBjb2xsaXNpb25CZWhhdmlvciwgekluZGV4LCB0aXRsZV0pO1xuICByZXR1cm4gW21hcmtlciwgY29udGVudENvbnRhaW5lcl07XG59XG5jb25zdCBBZHZhbmNlZE1hcmtlciA9IGZvcndhcmRSZWYoKHByb3BzLCByZWYpID0+IHtcbiAgY29uc3Qge1xuICAgIGNoaWxkcmVuXG4gIH0gPSBwcm9wcztcbiAgY29uc3QgW21hcmtlciwgY29udGVudENvbnRhaW5lcl0gPSB1c2VBZHZhbmNlZE1hcmtlcihwcm9wcyk7XG4gIHVzZUltcGVyYXRpdmVIYW5kbGUocmVmLCAoKSA9PiBtYXJrZXIsIFttYXJrZXJdKTtcbiAgaWYgKCFtYXJrZXIpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoQWR2YW5jZWRNYXJrZXJDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgdmFsdWU6IHtcbiAgICAgIG1hcmtlclxuICAgIH1cbiAgfSwgY29udGVudENvbnRhaW5lciAhPT0gbnVsbCAmJiBjcmVhdGVQb3J0YWwoY2hpbGRyZW4sIGNvbnRlbnRDb250YWluZXIpKTtcbn0pO1xuZnVuY3Rpb24gdXNlQWR2YW5jZWRNYXJrZXJSZWYoKSB7XG4gIGNvbnN0IFttYXJrZXIsIHNldE1hcmtlcl0gPSB1c2VTdGF0ZShudWxsKTtcbiAgY29uc3QgcmVmQ2FsbGJhY2sgPSB1c2VDYWxsYmFjayhtID0+IHtcbiAgICBzZXRNYXJrZXIobSk7XG4gIH0sIFtdKTtcbiAgcmV0dXJuIFtyZWZDYWxsYmFjaywgbWFya2VyXTtcbn1cblxuY29uc3QgX2V4Y2x1ZGVkJDEgPSBbXCJjaGlsZHJlblwiLCBcImFuY2hvclwiLCBcIm9uQ2xvc2VDbGlja1wiXTtcbi8qKlxuICogQ29tcG9uZW50IHRvIHJlbmRlciBhIEdvb2dsZSBNYXBzIEluZm8gV2luZG93XG4gKi9cbmNvbnN0IEluZm9XaW5kb3cgPSBwcm9wcyA9PiB7XG4gIHZhciBfdXNlQ29udGV4dDtcbiAgY29uc3Qge1xuICAgICAgY2hpbGRyZW4sXG4gICAgICBhbmNob3IsXG4gICAgICBvbkNsb3NlQ2xpY2tcbiAgICB9ID0gcHJvcHMsXG4gICAgaW5mb1dpbmRvd09wdGlvbnMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShwcm9wcywgX2V4Y2x1ZGVkJDEpO1xuICBjb25zdCBtYXAgPSAoX3VzZUNvbnRleHQgPSB1c2VDb250ZXh0KEdvb2dsZU1hcHNDb250ZXh0KSkgPT0gbnVsbCA/IHZvaWQgMCA6IF91c2VDb250ZXh0Lm1hcDtcbiAgY29uc3QgaW5mb1dpbmRvd1JlZiA9IHVzZVJlZihudWxsKTtcbiAgY29uc3QgW2NvbnRlbnRDb250YWluZXIsIHNldENvbnRlbnRDb250YWluZXJdID0gdXNlU3RhdGUobnVsbCk7XG4gIC8vIGNyZWF0ZSBpbmZvd2luZG93IG9uY2UgbWFwIGlzIGF2YWlsYWJsZVxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghbWFwKSByZXR1cm47XG4gICAgY29uc3QgbmV3SW5mb3dpbmRvdyA9IG5ldyBnb29nbGUubWFwcy5JbmZvV2luZG93KGluZm9XaW5kb3dPcHRpb25zKTtcbiAgICAvLyBBZGQgY29udGVudCB0byBpbmZvIHdpbmRvd1xuICAgIGNvbnN0IGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgbmV3SW5mb3dpbmRvdy5zZXRDb250ZW50KGVsKTtcbiAgICBpbmZvV2luZG93UmVmLmN1cnJlbnQgPSBuZXdJbmZvd2luZG93O1xuICAgIHNldENvbnRlbnRDb250YWluZXIoZWwpO1xuICAgIC8vIENsZWFudXAgaW5mbyB3aW5kb3cgYW5kIGV2ZW50IGxpc3RlbmVycyBvbiB1bm1vdW50XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LmNsZWFySW5zdGFuY2VMaXN0ZW5lcnMobmV3SW5mb3dpbmRvdyk7XG4gICAgICBuZXdJbmZvd2luZG93LmNsb3NlKCk7XG4gICAgICBlbC5yZW1vdmUoKTtcbiAgICAgIHNldENvbnRlbnRDb250YWluZXIobnVsbCk7XG4gICAgfTtcbiAgICAvLyBgaW5mb1dpbmRvd09wdGlvbnNgIGlzIG1pc3NpbmcgZnJvbSBkZXBlbmRlbmNpZXM6XG4gICAgLy9cbiAgICAvLyB3ZSBkb24ndCB3YW50IHRvIHJlLXJlbmRlciBhIHdob2xlIG5ldyBpbmZvd2luZG93XG4gICAgLy8gd2hlbiB0aGUgb3B0aW9ucyBjaGFuZ2UgdG8gcHJldmVudCBmbGlja2VyaW5nLlxuICAgIC8vIFVwZGF0ZSBvZiBpbmZvV2luZG93IG9wdGlvbnMgaXMgaGFuZGxlZCBpbiB0aGUgdXNlRWZmZWN0IGJlbG93LlxuICAgIC8vXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICB9LCBbbWFwLCBjaGlsZHJlbl0pO1xuICAvLyBVcGRhdGUgaW5mb1dpbmRvd09wdGlvbnNcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICB2YXIgX2luZm9XaW5kb3dSZWYkY3VycmVuO1xuICAgIChfaW5mb1dpbmRvd1JlZiRjdXJyZW4gPSBpbmZvV2luZG93UmVmLmN1cnJlbnQpID09IG51bGwgfHwgX2luZm9XaW5kb3dSZWYkY3VycmVuLnNldE9wdGlvbnMoaW5mb1dpbmRvd09wdGlvbnMpO1xuICB9LCBbaW5mb1dpbmRvd09wdGlvbnNdKTtcbiAgLy8gSGFuZGxlIHRoZSBjbG9zZSBjbGljayBjYWxsYmFja1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghaW5mb1dpbmRvd1JlZi5jdXJyZW50KSByZXR1cm47XG4gICAgbGV0IGxpc3RlbmVyID0gbnVsbDtcbiAgICBpZiAob25DbG9zZUNsaWNrKSB7XG4gICAgICBsaXN0ZW5lciA9IGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKGluZm9XaW5kb3dSZWYuY3VycmVudCwgJ2Nsb3NlY2xpY2snLCBvbkNsb3NlQ2xpY2spO1xuICAgIH1cbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgaWYgKGxpc3RlbmVyKSBsaXN0ZW5lci5yZW1vdmUoKTtcbiAgICB9O1xuICB9LCBbb25DbG9zZUNsaWNrXSk7XG4gIC8vIE9wZW4gaW5mbyB3aW5kb3cgYWZ0ZXIgY29udGVudCBjb250YWluZXIgaXMgc2V0XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgLy8gYW5jaG9yID09PSBudWxsIG1lYW5zIGFuIGFuY2hvciBpcyBkZWZpbmVkIGJ1dCBub3QgcmVhZHkgeWV0LlxuICAgIGlmICghY29udGVudENvbnRhaW5lciB8fCAhaW5mb1dpbmRvd1JlZi5jdXJyZW50IHx8IGFuY2hvciA9PT0gbnVsbCkgcmV0dXJuO1xuICAgIGNvbnN0IG9wZW5PcHRpb25zID0ge1xuICAgICAgbWFwXG4gICAgfTtcbiAgICBpZiAoYW5jaG9yKSB7XG4gICAgICBvcGVuT3B0aW9ucy5hbmNob3IgPSBhbmNob3I7XG4gICAgfVxuICAgIGluZm9XaW5kb3dSZWYuY3VycmVudC5vcGVuKG9wZW5PcHRpb25zKTtcbiAgfSwgW2NvbnRlbnRDb250YWluZXIsIGluZm9XaW5kb3dSZWYsIGFuY2hvciwgbWFwXSk7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChSZWFjdC5GcmFnbWVudCwgbnVsbCwgY29udGVudENvbnRhaW5lciAhPT0gbnVsbCAmJiBjcmVhdGVQb3J0YWwoY2hpbGRyZW4sIGNvbnRlbnRDb250YWluZXIpKTtcbn07XG5cbmNvbnN0IHNob3duTWVzc2FnZXMgPSBuZXcgU2V0KCk7XG5mdW5jdGlvbiBsb2dFcnJvck9uY2UoLi4uYXJncykge1xuICBjb25zdCBrZXkgPSBKU09OLnN0cmluZ2lmeShhcmdzKTtcbiAgaWYgKCFzaG93bk1lc3NhZ2VzLmhhcyhrZXkpKSB7XG4gICAgc2hvd25NZXNzYWdlcy5hZGQoa2V5KTtcbiAgICBjb25zb2xlLmVycm9yKC4uLmFyZ3MpO1xuICB9XG59XG5cbi8qKlxuICogUmV0cmlldmVzIGEgbWFwLWluc3RhbmNlIGZyb20gdGhlIGNvbnRleHQuIFRoaXMgaXMgZWl0aGVyIGFuIGluc3RhbmNlXG4gKiBpZGVudGlmaWVkIGJ5IGlkIG9yIHRoZSBwYXJlbnQgbWFwIGluc3RhbmNlIGlmIG5vIGlkIGlzIHNwZWNpZmllZC5cbiAqIFJldHVybnMgbnVsbCBpZiBuZWl0aGVyIGNhbiBiZSBmb3VuZC5cbiAqL1xuY29uc3QgdXNlTWFwID0gKGlkID0gbnVsbCkgPT4ge1xuICBjb25zdCBjdHggPSB1c2VDb250ZXh0KEFQSVByb3ZpZGVyQ29udGV4dCk7XG4gIGNvbnN0IHtcbiAgICBtYXBcbiAgfSA9IHVzZUNvbnRleHQoR29vZ2xlTWFwc0NvbnRleHQpIHx8IHt9O1xuICBpZiAoY3R4ID09PSBudWxsKSB7XG4gICAgbG9nRXJyb3JPbmNlKCd1c2VNYXAoKTogZmFpbGVkIHRvIHJldHJpZXZlIEFQSVByb3ZpZGVyQ29udGV4dC4gJyArICdNYWtlIHN1cmUgdGhhdCB0aGUgPEFQSVByb3ZpZGVyPiBjb21wb25lbnQgZXhpc3RzIGFuZCB0aGF0IHRoZSAnICsgJ2NvbXBvbmVudCB5b3UgYXJlIGNhbGxpbmcgYHVzZU1hcCgpYCBmcm9tIGlzIGEgc2libGluZyBvZiB0aGUgJyArICc8QVBJUHJvdmlkZXI+LicpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGNvbnN0IHtcbiAgICBtYXBJbnN0YW5jZXNcbiAgfSA9IGN0eDtcbiAgLy8gaWYgYW4gaWQgaXMgc3BlY2lmaWVkLCB0aGUgY29ycmVzcG9uZGluZyBtYXAgb3IgbnVsbCBpcyByZXR1cm5lZFxuICBpZiAoaWQgIT09IG51bGwpIHJldHVybiBtYXBJbnN0YW5jZXNbaWRdIHx8IG51bGw7XG4gIC8vIG90aGVyd2lzZSwgcmV0dXJuIHRoZSBjbG9zZXN0IGFuY2VzdG9yXG4gIGlmIChtYXApIHJldHVybiBtYXA7XG4gIC8vIGZpbmFsbHksIHJldHVybiB0aGUgZGVmYXVsdCBtYXAgaW5zdGFuY2VcbiAgcmV0dXJuIG1hcEluc3RhbmNlc1snZGVmYXVsdCddIHx8IG51bGw7XG59O1xuXG4vKipcbiAqIENvcHkgb2YgdGhlIGBnb29nbGUubWFwcy5Db250cm9sUG9zaXRpb25gIGNvbnN0YW50cy5cbiAqIFRoZXkgaGF2ZSB0byBiZSBkdXBsaWNhdGVkIGhlcmUgc2luY2Ugd2UgY2FuJ3Qgd2FpdCBmb3IgdGhlIG1hcHMgQVBJIHRvIGxvYWQgdG8gYmUgYWJsZSB0byB1c2UgdGhlbS5cbiAqL1xuY29uc3QgQ29udHJvbFBvc2l0aW9uID0ge1xuICBUT1BfTEVGVDogMSxcbiAgVE9QX0NFTlRFUjogMixcbiAgVE9QOiAyLFxuICBUT1BfUklHSFQ6IDMsXG4gIExFRlRfQ0VOVEVSOiA0LFxuICBMRUZUX1RPUDogNSxcbiAgTEVGVDogNSxcbiAgTEVGVF9CT1RUT006IDYsXG4gIFJJR0hUX1RPUDogNyxcbiAgUklHSFQ6IDcsXG4gIFJJR0hUX0NFTlRFUjogOCxcbiAgUklHSFRfQk9UVE9NOiA5LFxuICBCT1RUT01fTEVGVDogMTAsXG4gIEJPVFRPTV9DRU5URVI6IDExLFxuICBCT1RUT006IDExLFxuICBCT1RUT01fUklHSFQ6IDEyLFxuICBDRU5URVI6IDEzLFxuICBCTE9DS19TVEFSVF9JTkxJTkVfU1RBUlQ6IDE0LFxuICBCTE9DS19TVEFSVF9JTkxJTkVfQ0VOVEVSOiAxNSxcbiAgQkxPQ0tfU1RBUlRfSU5MSU5FX0VORDogMTYsXG4gIElOTElORV9TVEFSVF9CTE9DS19DRU5URVI6IDE3LFxuICBJTkxJTkVfU1RBUlRfQkxPQ0tfU1RBUlQ6IDE4LFxuICBJTkxJTkVfU1RBUlRfQkxPQ0tfRU5EOiAxOSxcbiAgSU5MSU5FX0VORF9CTE9DS19TVEFSVDogMjAsXG4gIElOTElORV9FTkRfQkxPQ0tfQ0VOVEVSOiAyMSxcbiAgSU5MSU5FX0VORF9CTE9DS19FTkQ6IDIyLFxuICBCTE9DS19FTkRfSU5MSU5FX1NUQVJUOiAyMyxcbiAgQkxPQ0tfRU5EX0lOTElORV9DRU5URVI6IDI0LFxuICBCTE9DS19FTkRfSU5MSU5FX0VORDogMjVcbn07XG5jb25zdCBNYXBDb250cm9sID0gKHtcbiAgY2hpbGRyZW4sXG4gIHBvc2l0aW9uXG59KSA9PiB7XG4gIGNvbnN0IGNvbnRyb2xDb250YWluZXIgPSB1c2VNZW1vKCgpID0+IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpLCBbXSk7XG4gIGNvbnN0IG1hcCA9IHVzZU1hcCgpO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghbWFwKSByZXR1cm47XG4gICAgY29uc3QgY29udHJvbHMgPSBtYXAuY29udHJvbHNbcG9zaXRpb25dO1xuICAgIGNvbnRyb2xzLnB1c2goY29udHJvbENvbnRhaW5lcik7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGNvbnN0IGluZGV4ID0gY29udHJvbHMuZ2V0QXJyYXkoKS5pbmRleE9mKGNvbnRyb2xDb250YWluZXIpO1xuICAgICAgY29udHJvbHMucmVtb3ZlQXQoaW5kZXgpO1xuICAgIH07XG4gIH0sIFtjb250cm9sQ29udGFpbmVyLCBtYXAsIHBvc2l0aW9uXSk7XG4gIHJldHVybiBjcmVhdGVQb3J0YWwoY2hpbGRyZW4sIGNvbnRyb2xDb250YWluZXIpO1xufTtcblxuY29uc3QgX2V4Y2x1ZGVkID0gW1wib25DbGlja1wiLCBcIm9uRHJhZ1wiLCBcIm9uRHJhZ1N0YXJ0XCIsIFwib25EcmFnRW5kXCIsIFwib25Nb3VzZU92ZXJcIiwgXCJvbk1vdXNlT3V0XCJdO1xuZnVuY3Rpb24gdXNlTWFya2VyKHByb3BzKSB7XG4gIHZhciBfdXNlQ29udGV4dDtcbiAgY29uc3QgW21hcmtlciwgc2V0TWFya2VyXSA9IHVzZVN0YXRlKG51bGwpO1xuICBjb25zdCBtYXAgPSAoX3VzZUNvbnRleHQgPSB1c2VDb250ZXh0KEdvb2dsZU1hcHNDb250ZXh0KSkgPT0gbnVsbCA/IHZvaWQgMCA6IF91c2VDb250ZXh0Lm1hcDtcbiAgY29uc3Qge1xuICAgICAgb25DbGljayxcbiAgICAgIG9uRHJhZyxcbiAgICAgIG9uRHJhZ1N0YXJ0LFxuICAgICAgb25EcmFnRW5kLFxuICAgICAgb25Nb3VzZU92ZXIsXG4gICAgICBvbk1vdXNlT3V0XG4gICAgfSA9IHByb3BzLFxuICAgIG1hcmtlck9wdGlvbnMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShwcm9wcywgX2V4Y2x1ZGVkKTtcbiAgY29uc3Qge1xuICAgIHBvc2l0aW9uLFxuICAgIGRyYWdnYWJsZVxuICB9ID0gbWFya2VyT3B0aW9ucztcbiAgLy8gY3JlYXRlIG1hcmtlciBpbnN0YW5jZSBhbmQgYWRkIHRvIHRoZSBtYXAgb25jZSB0aGUgbWFwIGlzIGF2YWlsYWJsZVxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghbWFwKSB7XG4gICAgICBpZiAobWFwID09PSB1bmRlZmluZWQpIGNvbnNvbGUuZXJyb3IoJzxNYXJrZXI+IGhhcyB0byBiZSBpbnNpZGUgYSBNYXAgY29tcG9uZW50LicpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBuZXdNYXJrZXIgPSBuZXcgZ29vZ2xlLm1hcHMuTWFya2VyKG1hcmtlck9wdGlvbnMpO1xuICAgIG5ld01hcmtlci5zZXRNYXAobWFwKTtcbiAgICBzZXRNYXJrZXIobmV3TWFya2VyKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgbmV3TWFya2VyLnNldE1hcChudWxsKTtcbiAgICAgIHNldE1hcmtlcihudWxsKTtcbiAgICB9O1xuICAgIC8vIFdlIGRvIG5vdCB3YW50IHRvIHJlLXJlbmRlciB0aGUgd2hvbGUgbWFya2VyIHdoZW4gdGhlIG9wdGlvbnMgY2hhbmdlLlxuICAgIC8vIE1hcmtlciBvcHRpb25zIHVwZGF0ZSBpcyBoYW5kbGVkIGluIGEgdXNlRWZmZWN0IGJlbG93LlxuICAgIC8vIEV4Y2x1ZGluZyBtYXJrZXJPcHRpb25zIGZyb20gZGVwZW5kZW5jeSBhcnJheSBvbiBwdXJwb3NlIGhlcmUuXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICB9LCBbbWFwXSk7XG4gIC8vIGF0dGFjaCBhbmQgcmUtYXR0YWNoIGV2ZW50LWhhbmRsZXJzIHdoZW4gYW55IG9mIHRoZSBwcm9wZXJ0aWVzIGNoYW5nZVxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghbWFya2VyKSByZXR1cm47XG4gICAgY29uc3QgbSA9IG1hcmtlcjtcbiAgICAvLyBBZGQgZXZlbnQgbGlzdGVuZXJzXG4gICAgY29uc3QgZ21lID0gZ29vZ2xlLm1hcHMuZXZlbnQ7XG4gICAgaWYgKG9uQ2xpY2spIGdtZS5hZGRMaXN0ZW5lcihtLCAnY2xpY2snLCBvbkNsaWNrKTtcbiAgICBpZiAob25EcmFnKSBnbWUuYWRkTGlzdGVuZXIobSwgJ2RyYWcnLCBvbkRyYWcpO1xuICAgIGlmIChvbkRyYWdTdGFydCkgZ21lLmFkZExpc3RlbmVyKG0sICdkcmFnc3RhcnQnLCBvbkRyYWdTdGFydCk7XG4gICAgaWYgKG9uRHJhZ0VuZCkgZ21lLmFkZExpc3RlbmVyKG0sICdkcmFnZW5kJywgb25EcmFnRW5kKTtcbiAgICBpZiAob25Nb3VzZU92ZXIpIGdtZS5hZGRMaXN0ZW5lcihtLCAnbW91c2VvdmVyJywgb25Nb3VzZU92ZXIpO1xuICAgIGlmIChvbk1vdXNlT3V0KSBnbWUuYWRkTGlzdGVuZXIobSwgJ21vdXNlb3V0Jywgb25Nb3VzZU91dCk7XG4gICAgbWFya2VyLnNldERyYWdnYWJsZShCb29sZWFuKGRyYWdnYWJsZSkpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBnbWUuY2xlYXJJbnN0YW5jZUxpc3RlbmVycyhtKTtcbiAgICB9O1xuICB9LCBbbWFya2VyLCBkcmFnZ2FibGUsIG9uQ2xpY2ssIG9uRHJhZywgb25EcmFnU3RhcnQsIG9uRHJhZ0VuZCwgb25Nb3VzZU92ZXIsIG9uTW91c2VPdXRdKTtcbiAgLy8gdXBkYXRlIG1hcmtlck9wdGlvbnMgKG5vdGUgdGhlIGRlcGVuZGVuY2llcyBhcmVuJ3QgcHJvcGVybHkgY2hlY2tlZFxuICAvLyBoZXJlLCB3ZSBqdXN0IGFzc3VtZSB0aGF0IHNldE9wdGlvbnMgaXMgc21hcnQgZW5vdWdoIHRvIG5vdCB3YXN0ZSBhXG4gIC8vIGxvdCBvZiB0aW1lIHVwZGF0aW5nIHZhbHVlcyB0aGF0IGRpZG4ndCBjaGFuZ2UpXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFtYXJrZXIpIHJldHVybjtcbiAgICBpZiAobWFya2VyT3B0aW9ucykgbWFya2VyLnNldE9wdGlvbnMobWFya2VyT3B0aW9ucyk7XG4gIH0sIFttYXJrZXIsIG1hcmtlck9wdGlvbnNdKTtcbiAgLy8gdXBkYXRlIHBvc2l0aW9uIHdoZW4gY2hhbmdlZFxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIC8vIFNob3VsZCBub3QgdXBkYXRlIHBvc2l0aW9uIHdoZW4gZHJhZ2dhYmxlXG4gICAgaWYgKGRyYWdnYWJsZSB8fCAhcG9zaXRpb24gfHwgIW1hcmtlcikgcmV0dXJuO1xuICAgIG1hcmtlci5zZXRQb3NpdGlvbihwb3NpdGlvbik7XG4gIH0sIFtkcmFnZ2FibGUsIHBvc2l0aW9uLCBtYXJrZXJdKTtcbiAgcmV0dXJuIG1hcmtlcjtcbn1cbi8qKlxuICogQ29tcG9uZW50IHRvIHJlbmRlciBhIEdvb2dsZSBNYXBzIE1hcmtlciBvbiBhIG1hcFxuICovXG5jb25zdCBNYXJrZXIgPSBmb3J3YXJkUmVmKChwcm9wcywgcmVmKSA9PiB7XG4gIGNvbnN0IG1hcmtlciA9IHVzZU1hcmtlcihwcm9wcyk7XG4gIHVzZUltcGVyYXRpdmVIYW5kbGUocmVmLCAoKSA9PiBtYXJrZXIsIFttYXJrZXJdKTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0LkZyYWdtZW50LCBudWxsKTtcbn0pO1xuZnVuY3Rpb24gdXNlTWFya2VyUmVmKCkge1xuICBjb25zdCBbbWFya2VyLCBzZXRNYXJrZXJdID0gdXNlU3RhdGUobnVsbCk7XG4gIGNvbnN0IHJlZkNhbGxiYWNrID0gdXNlQ2FsbGJhY2sobSA9PiB7XG4gICAgc2V0TWFya2VyKG0pO1xuICB9LCBbXSk7XG4gIHJldHVybiBbcmVmQ2FsbGJhY2ssIG1hcmtlcl07XG59XG5cbi8qKlxuICogQ29tcG9uZW50IHRvIHJlbmRlciBhIGdvb2dsZSBtYXBzIG1hcmtlciBQaW4gVmlld1xuICovXG5jb25zdCBQaW4gPSBwcm9wcyA9PiB7XG4gIHZhciBfdXNlQ29udGV4dDtcbiAgY29uc3QgYWR2YW5jZWRNYXJrZXIgPSAoX3VzZUNvbnRleHQgPSB1c2VDb250ZXh0KEFkdmFuY2VkTWFya2VyQ29udGV4dCkpID09IG51bGwgPyB2b2lkIDAgOiBfdXNlQ29udGV4dC5tYXJrZXI7XG4gIGNvbnN0IGdseXBoQ29udGFpbmVyID0gdXNlTWVtbygoKSA9PiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKSwgW10pO1xuICAvLyBDcmVhdGUgUGluIFZpZXcgaW5zdGFuY2VcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIWFkdmFuY2VkTWFya2VyKSB7XG4gICAgICBpZiAoYWR2YW5jZWRNYXJrZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdUaGUgPFBpbj4gY29tcG9uZW50IGNhbiBvbmx5IGJlIHVzZWQgaW5zaWRlIDxBZHZhbmNlZE1hcmtlcj4uJyk7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChwcm9wcy5nbHlwaCAmJiBwcm9wcy5jaGlsZHJlbikge1xuICAgICAgbG9nRXJyb3JPbmNlKCdUaGUgPFBpbj4gY29tcG9uZW50IG9ubHkgdXNlcyBjaGlsZHJlbiB0byByZW5kZXIgdGhlIGdseXBoIGlmIGJvdGggdGhlIGdseXBoIHByb3BlcnR5IGFuZCBjaGlsZHJlbiBhcmUgcHJlc2VudC4nKTtcbiAgICB9XG4gICAgaWYgKENoaWxkcmVuLmNvdW50KHByb3BzLmNoaWxkcmVuKSA+IDEpIHtcbiAgICAgIGxvZ0Vycm9yT25jZSgnUGFzc2luZyBtdWx0aXBsZSBjaGlsZHJlbiB0byB0aGUgPFBpbj4gY29tcG9uZW50IG1pZ2h0IGxlYWQgdG8gdW5leHBlY3RlZCByZXN1bHRzLicpO1xuICAgIH1cbiAgICBjb25zdCBwaW5WaWV3T3B0aW9ucyA9IF9leHRlbmRzKHt9LCBwcm9wcyk7XG4gICAgY29uc3QgcGluRWxlbWVudCA9IG5ldyBnb29nbGUubWFwcy5tYXJrZXIuUGluRWxlbWVudChwaW5WaWV3T3B0aW9ucyk7XG4gICAgLy8gU2V0IGdseXBoIHRvIGdseXBoIGNvbnRhaW5lciBpZiBjaGlsZHJlbiBhcmUgcHJlc2VudCAocmVuZGVyZWQgdmlhIHBvcnRhbCkuXG4gICAgLy8gSWYgYm90aCBwcm9wcy5nbHlwaCBhbmQgcHJvcHMuY2hpbGRyZW4gYXJlIHByZXNlbnQsIHByb3BzLmNoaWxkcmVuIHRha2VzIHByaW9yaXR5LlxuICAgIGlmIChwcm9wcy5jaGlsZHJlbikge1xuICAgICAgcGluRWxlbWVudC5nbHlwaCA9IGdseXBoQ29udGFpbmVyO1xuICAgIH1cbiAgICAvLyBTZXQgY29udGVudCBvZiBBZHZhbmNlZCBNYXJrZXIgVmlldyB0byB0aGUgUGluIFZpZXcgZWxlbWVudFxuICAgIGFkdmFuY2VkTWFya2VyLmNvbnRlbnQgPSBwaW5FbGVtZW50LmVsZW1lbnQ7XG4gIH0sIFthZHZhbmNlZE1hcmtlciwgZ2x5cGhDb250YWluZXIsIHByb3BzXSk7XG4gIHJldHVybiBjcmVhdGVQb3J0YWwocHJvcHMuY2hpbGRyZW4sIGdseXBoQ29udGFpbmVyKTtcbn07XG5cbmNvbnN0IG1hcExpbmVhciA9ICh4LCBhMSwgYTIsIGIxLCBiMikgPT4gYjEgKyAoeCAtIGExKSAqIChiMiAtIGIxKSAvIChhMiAtIGExKTtcbmNvbnN0IGdldE1hcE1heFRpbHQgPSB6b29tID0+IHtcbiAgaWYgKHpvb20gPD0gMTApIHtcbiAgICByZXR1cm4gMzA7XG4gIH1cbiAgaWYgKHpvb20gPj0gMTUuNSkge1xuICAgIHJldHVybiA2Ny41O1xuICB9XG4gIC8vIHJhbmdlIFsxMC4uLjE0XVxuICBpZiAoem9vbSA8PSAxNCkge1xuICAgIHJldHVybiBtYXBMaW5lYXIoem9vbSwgMTAsIDE0LCAzMCwgNDUpO1xuICB9XG4gIC8vIHJhbmdlIFsxNC4uLjE1LjVdXG4gIHJldHVybiBtYXBMaW5lYXIoem9vbSwgMTQsIDE1LjUsIDQ1LCA2Ny41KTtcbn07XG4vKipcbiAqIEZ1bmN0aW9uIHRvIGxpbWl0IHRoZSB0aWx0IHJhbmdlIG9mIHRoZSBnb29nbGUgbWFwcyBtYXAgd2hlbiB1cGRhdGluZyB0aGUgdmlldyBzdGF0ZVxuICovXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuY29uc3QgbGltaXRUaWx0UmFuZ2UgPSAoe1xuICB2aWV3U3RhdGVcbn0pID0+IHtcbiAgY29uc3QgcGl0Y2ggPSB2aWV3U3RhdGUucGl0Y2g7XG4gIGNvbnN0IGdtWm9vbSA9IHZpZXdTdGF0ZS56b29tICsgMTtcbiAgY29uc3QgbWF4VGlsdCA9IGdldE1hcE1heFRpbHQoZ21ab29tKTtcbiAgcmV0dXJuIF9leHRlbmRzKHt9LCB2aWV3U3RhdGUsIHtcbiAgICBmb3Z5OiAyNSxcbiAgICBwaXRjaDogTWF0aC5taW4obWF4VGlsdCwgcGl0Y2gpXG4gIH0pO1xufTtcblxuZXhwb3J0IHsgQVBJTG9hZGluZ1N0YXR1cywgQVBJUHJvdmlkZXIsIEFQSVByb3ZpZGVyQ29udGV4dCwgQWR2YW5jZWRNYXJrZXIsIEFkdmFuY2VkTWFya2VyQ29udGV4dCwgQ29udHJvbFBvc2l0aW9uLCBHb29nbGVNYXBzQ29udGV4dCwgSW5mb1dpbmRvdywgTWFwLCBNYXBDb250cm9sLCBNYXJrZXIsIFBpbiwgaXNMYXRMbmdMaXRlcmFsLCBsYXRMbmdFcXVhbHMsIGxpbWl0VGlsdFJhbmdlLCB0b0xhdExuZ0xpdGVyYWwsIHVzZUFkdmFuY2VkTWFya2VyUmVmLCB1c2VBcGlJc0xvYWRlZCwgdXNlQXBpTG9hZGluZ1N0YXR1cywgdXNlTWFwLCB1c2VNYXBzTGlicmFyeSwgdXNlTWFya2VyUmVmIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tb2Rlcm4ubWpzLm1hcFxuIl0sIm5hbWVzIjpbIlJlYWN0IiwidXNlU3RhdGUiLCJ1c2VSZWR1Y2VyIiwidXNlTWVtbyIsInVzZUNhbGxiYWNrIiwidXNlRWZmZWN0IiwidXNlUmVmIiwidXNlQ29udGV4dCIsInVzZUxheW91dEVmZmVjdCIsImZvcndhcmRSZWYiLCJ1c2VJbXBlcmF0aXZlSGFuZGxlIiwiQ2hpbGRyZW4iLCJjcmVhdGVQb3J0YWwiLCJpc0RlZXBFcXVhbCIsIl90b1ByaW1pdGl2ZSIsInQiLCJyIiwiZSIsIlN5bWJvbCIsInRvUHJpbWl0aXZlIiwiaSIsImNhbGwiLCJUeXBlRXJyb3IiLCJTdHJpbmciLCJOdW1iZXIiLCJfdG9Qcm9wZXJ0eUtleSIsIl9leHRlbmRzIiwiT2JqZWN0IiwiYXNzaWduIiwiYmluZCIsInRhcmdldCIsImFyZ3VtZW50cyIsImxlbmd0aCIsInNvdXJjZSIsImtleSIsInByb3RvdHlwZSIsImhhc093blByb3BlcnR5IiwiYXBwbHkiLCJfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZSIsImV4Y2x1ZGVkIiwic291cmNlS2V5cyIsImtleXMiLCJpbmRleE9mIiwiQVBJTG9hZGluZ1N0YXR1cyIsIk5PVF9MT0FERUQiLCJMT0FESU5HIiwiTE9BREVEIiwiRkFJTEVEIiwiQVVUSF9GQUlMVVJFIiwiTUFQU19BUElfQkFTRV9VUkwiLCJHb29nbGVNYXBzQXBpTG9hZGVyIiwibG9hZCIsInBhcmFtcyIsIm9uTG9hZGluZ1N0YXR1c0NoYW5nZSIsIl93aW5kb3ckZ29vZ2xlIiwibGlicmFyaWVzIiwic3BsaXQiLCJzZXJpYWxpemVkUGFyYW1zIiwic2VyaWFsaXplUGFyYW1zIiwid2luZG93IiwiZ29vZ2xlIiwibWFwcyIsImltcG9ydExpYnJhcnkiLCJzZXJpYWxpemVkQXBpUGFyYW1zIiwiaW5pdEltcG9ydExpYnJhcnkiLCJsb2FkaW5nU3RhdHVzIiwiY29uc29sZSIsIndhcm4iLCJsaWIiLCJ2IiwibGFuZ3VhZ2UiLCJyZWdpb24iLCJhdXRoUmVmZXJyZXJQb2xpY3kiLCJzb2x1dGlvbkNoYW5uZWwiLCJqb2luIiwiYXBpUHJvbWlzZSIsImxvYWRBcGkiLCJsaWJyYXJ5IiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJfZG9jdW1lbnQkcXVlcnlTZWxlY3QiLCJzY3JpcHRFbGVtZW50IiwiZG9jdW1lbnQiLCJjcmVhdGVFbGVtZW50IiwidXJsUGFyYW1zIiwiVVJMU2VhcmNoUGFyYW1zIiwidmFsdWUiLCJlbnRyaWVzIiwidXJsUGFyYW1OYW1lIiwicmVwbGFjZSIsInRvTG93ZXJDYXNlIiwic2V0IiwiYXN5bmMiLCJzcmMiLCJ0b1N0cmluZyIsIl9fZ29vZ2xlTWFwc0NhbGxiYWNrX18iLCJnbV9hdXRoRmFpbHVyZSIsIm9uZXJyb3IiLCJFcnJvciIsIm5vbmNlIiwicXVlcnlTZWxlY3RvciIsImhlYWQiLCJhcHBlbmQiLCJsaWJyYXJ5TmFtZSIsInRoZW4iLCJfZXhjbHVkZWQkMyIsIl9leGNsdWRlZDIiLCJBUElQcm92aWRlckNvbnRleHQiLCJjcmVhdGVDb250ZXh0IiwidXNlTWFwSW5zdGFuY2VzIiwibWFwSW5zdGFuY2VzIiwic2V0TWFwSW5zdGFuY2VzIiwiYWRkTWFwSW5zdGFuY2UiLCJtYXBJbnN0YW5jZSIsImlkIiwiaW5zdGFuY2VzIiwicmVtb3ZlTWFwSW5zdGFuY2UiLCJfcmVmIiwicmVtYWluaW5nIiwibWFwIiwiY2xlYXJNYXBJbnN0YW5jZXMiLCJ1c2VHb29nbGVNYXBzQXBpTG9hZGVyIiwicHJvcHMiLCJvbkxvYWQiLCJhcGlLZXkiLCJ2ZXJzaW9uIiwib3RoZXJBcGlQYXJhbXMiLCJzdGF0dXMiLCJzZXRTdGF0dXMiLCJsb2FkZWRMaWJyYXJpZXMiLCJhZGRMb2FkZWRMaWJyYXJ5IiwiYWN0aW9uIiwibmFtZSIsImxpYnJhcmllc1N0cmluZyIsIkpTT04iLCJzdHJpbmdpZnkiLCJfZ29vZ2xlIiwicmVzIiwiZXJyb3IiLCJBUElQcm92aWRlciIsImNoaWxkcmVuIiwibG9hZGVyUHJvcHMiLCJQcm92aWRlciIsInVzZU1hcEV2ZW50cyIsInByb3BOYW1lIiwiZXZlbnRQcm9wTmFtZXMiLCJoYW5kbGVyIiwiZXZlbnRUeXBlIiwicHJvcE5hbWVUb0V2ZW50VHlwZSIsImxpc3RlbmVyIiwiZXZlbnQiLCJhZGRMaXN0ZW5lciIsImV2IiwiY3JlYXRlTWFwRXZlbnQiLCJyZW1vdmUiLCJ0eXBlIiwic3JjRXZlbnQiLCJkZXRhaWwiLCJzdG9wcGFibGUiLCJzdG9wIiwiY2FtZXJhRXZlbnRUeXBlcyIsImluY2x1ZGVzIiwiY2FtRXZlbnQiLCJjZW50ZXIiLCJnZXRDZW50ZXIiLCJ6b29tIiwiZ2V0Wm9vbSIsImhlYWRpbmciLCJnZXRIZWFkaW5nIiwidGlsdCIsImdldFRpbHQiLCJib3VuZHMiLCJnZXRCb3VuZHMiLCJpc0Zpbml0ZSIsInRvSlNPTiIsImxhdCIsImxuZyIsIm5vcnRoIiwiZWFzdCIsInNvdXRoIiwid2VzdCIsIm1vdXNlRXZlbnRUeXBlcyIsIl9zcmNFdmVudCRsYXRMbmciLCJtb3VzZUV2ZW50IiwiZG9tRXZlbnQiLCJsYXRMbmciLCJwbGFjZUlkIiwib25Cb3VuZHNDaGFuZ2VkIiwib25DZW50ZXJDaGFuZ2VkIiwib25DbGljayIsIm9uQ29udGV4dG1lbnUiLCJvbkRibGNsaWNrIiwib25EcmFnIiwib25EcmFnZW5kIiwib25EcmFnc3RhcnQiLCJvbkhlYWRpbmdDaGFuZ2VkIiwib25JZGxlIiwib25Jc0ZyYWN0aW9uYWxab29tRW5hYmxlZENoYW5nZWQiLCJvbk1hcENhcGFiaWxpdGllc0NoYW5nZWQiLCJvbk1hcFR5cGVJZENoYW5nZWQiLCJvbk1vdXNlbW92ZSIsIm9uTW91c2VvdXQiLCJvbk1vdXNlb3ZlciIsIm9uUHJvamVjdGlvbkNoYW5nZWQiLCJvblJlbmRlcmluZ1R5cGVDaGFuZ2VkIiwib25UaWxlc0xvYWRlZCIsIm9uVGlsdENoYW5nZWQiLCJvblpvb21DaGFuZ2VkIiwib25DYW1lcmFDaGFuZ2VkIiwidXNlRGVlcENvbXBhcmVFZmZlY3QiLCJlZmZlY3QiLCJkZXBzIiwicmVmIiwidW5kZWZpbmVkIiwiY3VycmVudCIsIm1hcE9wdGlvbktleXMiLCJTZXQiLCJ1c2VNYXBPcHRpb25zIiwibWFwUHJvcHMiLCJtYXBPcHRpb25zIiwiaGFzIiwic2V0T3B0aW9ucyIsInVzZUFwaUxvYWRpbmdTdGF0dXMiLCJfdXNlQ29udGV4dCIsInVzZURlY2tHTENhbWVyYVVwZGF0ZSIsInZpZXdwb3J0Iiwidmlld1N0YXRlIiwiaXNEZWNrR2xDb250cm9sbGVkIiwibGF0aXR1ZGUiLCJsb25naXR1ZGUiLCJiZWFyaW5nIiwicGl0Y2giLCJtb3ZlQ2FtZXJhIiwiaXNMYXRMbmdMaXRlcmFsIiwib2JqIiwibGF0TG5nRXF1YWxzIiwiYSIsImIiLCJBIiwidG9MYXRMbmdMaXRlcmFsIiwiQiIsInVzZU1hcENhbWVyYVBhcmFtcyIsImNhbWVyYVN0YXRlUmVmIiwibmV4dENhbWVyYSIsIm5lZWRzVXBkYXRlIiwiQXV0aEZhaWx1cmVNZXNzYWdlIiwic3R5bGUiLCJwb3NpdGlvbiIsInRvcCIsImxlZnQiLCJib3R0b20iLCJyaWdodCIsInpJbmRleCIsImRpc3BsYXkiLCJmbGV4RmxvdyIsInRleHRBbGlnbiIsImp1c3RpZnlDb250ZW50IiwiZm9udFNpemUiLCJjb2xvciIsImJhY2tncm91bmQiLCJwYWRkaW5nIiwidXNlQ2FsbGJhY2tSZWYiLCJlbCIsInNldEVsIiwidXNlQXBpSXNMb2FkZWQiLCJ1c2VGb3JjZVVwZGF0ZSIsImZvcmNlVXBkYXRlIiwieCIsImhhbmRsZUJvdW5kc0NoYW5nZSIsInVzZVRyYWNrZWRDYW1lcmFTdGF0ZVJlZiIsIl9leGNsdWRlZCQyIiwidXNlTWFwSW5zdGFuY2UiLCJjb250ZXh0IiwiYXBpSXNMb2FkZWQiLCJzZXRNYXAiLCJjb250YWluZXIiLCJjb250YWluZXJSZWYiLCJkZWZhdWx0Qm91bmRzIiwiZGVmYXVsdENlbnRlciIsImRlZmF1bHRab29tIiwiZGVmYXVsdEhlYWRpbmciLCJkZWZhdWx0VGlsdCIsInNhdmVkTWFwU3RhdGVSZWYiLCJtYXBJZCIsIm5ld01hcCIsIk1hcCIsImZpdEJvdW5kcyIsInNhdmVkTWFwSWQiLCJjYW1lcmFTdGF0ZSIsInNhdmVkQ2FtZXJhU3RhdGUiLCJjbGVhckluc3RhbmNlTGlzdGVuZXJzIiwiR29vZ2xlTWFwc0NvbnRleHQiLCJjbGFzc05hbWUiLCJtYXBSZWYiLCJpc0NvbnRyb2xsZWRFeHRlcm5hbGx5IiwiY29udHJvbGxlZCIsImRpc2FibGVEZWZhdWx0VUkiLCJnZXN0dXJlSGFuZGxpbmciLCJrZXlib2FyZFNob3J0Y3V0cyIsImNhbWVyYU9wdGlvbnMiLCJfbGF0IiwiX2xuZyIsIl9wcm9wcyR6b29tIiwiX3Byb3BzJGhlYWRpbmciLCJfcHJvcHMkdGlsdCIsImNvbWJpbmVkU3R5bGUiLCJ3aWR0aCIsImhlaWdodCIsImRlY2tHTFZpZXdQcm9wcyIsInVzZU1hcHNMaWJyYXJ5IiwiY3R4IiwiQWR2YW5jZWRNYXJrZXJDb250ZXh0IiwidXNlQWR2YW5jZWRNYXJrZXIiLCJtYXJrZXIiLCJzZXRNYXJrZXIiLCJjb250ZW50Q29udGFpbmVyIiwic2V0Q29udGVudENvbnRhaW5lciIsIm1hcmtlckxpYnJhcnkiLCJvbkRyYWdTdGFydCIsIm9uRHJhZ0VuZCIsImNvbGxpc2lvbkJlaGF2aW9yIiwiZHJhZ2dhYmxlIiwidGl0bGUiLCJudW1DaGlsZHMiLCJjb3VudCIsIm5ld01hcmtlciIsIkFkdmFuY2VkTWFya2VyRWxlbWVudCIsImNvbnRlbnQiLCJnbWUiLCJtIiwiZ21wRHJhZ2dhYmxlIiwiQWR2YW5jZWRNYXJrZXIiLCJ1c2VBZHZhbmNlZE1hcmtlclJlZiIsInJlZkNhbGxiYWNrIiwiX2V4Y2x1ZGVkJDEiLCJJbmZvV2luZG93IiwiYW5jaG9yIiwib25DbG9zZUNsaWNrIiwiaW5mb1dpbmRvd09wdGlvbnMiLCJpbmZvV2luZG93UmVmIiwibmV3SW5mb3dpbmRvdyIsInNldENvbnRlbnQiLCJjbG9zZSIsIl9pbmZvV2luZG93UmVmJGN1cnJlbiIsIm9wZW5PcHRpb25zIiwib3BlbiIsIkZyYWdtZW50Iiwic2hvd25NZXNzYWdlcyIsImxvZ0Vycm9yT25jZSIsImFyZ3MiLCJhZGQiLCJ1c2VNYXAiLCJDb250cm9sUG9zaXRpb24iLCJUT1BfTEVGVCIsIlRPUF9DRU5URVIiLCJUT1AiLCJUT1BfUklHSFQiLCJMRUZUX0NFTlRFUiIsIkxFRlRfVE9QIiwiTEVGVCIsIkxFRlRfQk9UVE9NIiwiUklHSFRfVE9QIiwiUklHSFQiLCJSSUdIVF9DRU5URVIiLCJSSUdIVF9CT1RUT00iLCJCT1RUT01fTEVGVCIsIkJPVFRPTV9DRU5URVIiLCJCT1RUT00iLCJCT1RUT01fUklHSFQiLCJDRU5URVIiLCJCTE9DS19TVEFSVF9JTkxJTkVfU1RBUlQiLCJCTE9DS19TVEFSVF9JTkxJTkVfQ0VOVEVSIiwiQkxPQ0tfU1RBUlRfSU5MSU5FX0VORCIsIklOTElORV9TVEFSVF9CTE9DS19DRU5URVIiLCJJTkxJTkVfU1RBUlRfQkxPQ0tfU1RBUlQiLCJJTkxJTkVfU1RBUlRfQkxPQ0tfRU5EIiwiSU5MSU5FX0VORF9CTE9DS19TVEFSVCIsIklOTElORV9FTkRfQkxPQ0tfQ0VOVEVSIiwiSU5MSU5FX0VORF9CTE9DS19FTkQiLCJCTE9DS19FTkRfSU5MSU5FX1NUQVJUIiwiQkxPQ0tfRU5EX0lOTElORV9DRU5URVIiLCJCTE9DS19FTkRfSU5MSU5FX0VORCIsIk1hcENvbnRyb2wiLCJjb250cm9sQ29udGFpbmVyIiwiY29udHJvbHMiLCJwdXNoIiwiaW5kZXgiLCJnZXRBcnJheSIsInJlbW92ZUF0IiwiX2V4Y2x1ZGVkIiwidXNlTWFya2VyIiwib25Nb3VzZU92ZXIiLCJvbk1vdXNlT3V0IiwibWFya2VyT3B0aW9ucyIsIk1hcmtlciIsInNldERyYWdnYWJsZSIsIkJvb2xlYW4iLCJzZXRQb3NpdGlvbiIsInVzZU1hcmtlclJlZiIsIlBpbiIsImFkdmFuY2VkTWFya2VyIiwiZ2x5cGhDb250YWluZXIiLCJnbHlwaCIsInBpblZpZXdPcHRpb25zIiwicGluRWxlbWVudCIsIlBpbkVsZW1lbnQiLCJlbGVtZW50IiwibWFwTGluZWFyIiwiYTEiLCJhMiIsImIxIiwiYjIiLCJnZXRNYXBNYXhUaWx0IiwibGltaXRUaWx0UmFuZ2UiLCJnbVpvb20iLCJtYXhUaWx0IiwiZm92eSIsIk1hdGgiLCJtaW4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@vis.gl/react-google-maps/dist/index.modern.mjs\n");

/***/ })

};
;